<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FIUP Tool v3.3 - å¢é‡è¡¥ä¸ + å¤šç›®æ ‡å®šä½</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            gray: {
              950: '#0a0a0f',
              900: '#111118',
              800: '#1a1a24',
              700: '#2a2a38',
              600: '#3a3a4a',
              500: '#5a5a6a',
              400: '#8a8a9a',
              300: '#b0b0c0',
            }
          }
        }
      }
    }
  </script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    pre, code, .font-mono { font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #3a3a4a; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #5a5a6a; }
    textarea.edit-area { tab-size: 2; }
    .whitespace-visible { white-space: pre; }
    .whitespace-visible .space::before { content: 'Â·'; color: #3a3a4a; }
    .whitespace-visible .tab::before { content: 'â†’'; color: #5a5a6a; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useCallback, useMemo } = React;

    const Icons = {
      Upload: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>,
      FileText: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><line x1="10" y1="9" x2="8" y2="9"/></svg>,
      FilePlus: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="12" y1="18" x2="12" y2="12"/><line x1="9" y1="15" x2="15" y2="15"/></svg>,
      Play: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
      Eye: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>,
      EyeOff: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>,
      CheckCircle: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>,
      XCircle: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>,
      AlertTriangle: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>,
      Copy: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>,
      Trash2: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>,
      ChevronDown: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 12 15 18 9"/></svg>,
      ChevronRight: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6"/></svg>,
      Code: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props?.size || 20} height={props?.size || 20} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>,
      RefreshCw: () => <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>,
      Github: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>,
      Download: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>,
      Edit: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>,
      Save: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>,
      X: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>,
      Info: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>,
      Zap: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>,
      Layers: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>,
      Target: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>,
      MapPin: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>,
    };

    // FIUP v3.0 è§£æå™¨
    const parseFIUP = (text) => {
      let content = text;
      const codeBlockPattern = /```(?:fiup)?\s*\n([\s\S]*?)```/g;
      let extracted = '';
      let match;
      while ((match = codeBlockPattern.exec(text)) !== null) {
        extracted += match[1] + '\n';
      }
      if (extracted) content = extracted;
      
      const patches = [];
      const blockPattern = /<<<FIUP>>>([\s\S]*?)<<<END>>>/g;
      
      while ((match = blockPattern.exec(content)) !== null) {
        const block = match[0];
        const inner = match[1];
        
        const fileMatch = inner.match(/\[FILE\]:\s*(.+?)(?:\n|$)/);
        const file = fileMatch ? fileMatch[1].trim() : '';
        
        const opMatch = inner.match(/\[OP\]:\s*(REPLACE|INSERT_AFTER|INSERT_BEFORE|DELETE|CREATE)(?:\n|$)/i);
        const operation = opMatch ? opMatch[1].toUpperCase() : '';
        
        let anchor = '';
        let contentText = '';
        
        const anchorMatch = inner.match(/\[ANCHOR\]\s*\n([\s\S]*?)(?=\[CONTENT\]|$)/);
        if (anchorMatch) anchor = anchorMatch[1].replace(/\n$/, '');
        
        const contentMatch = inner.match(/\[CONTENT\]\s*\n([\s\S]*?)$/);
        if (contentMatch) contentText = contentMatch[1].replace(/\n$/, '');
        
        patches.push({
          id: crypto.randomUUID(),
          file,
          operation,
          anchor,
          content: contentText,
          raw: block,
          selectedMatchIndex: null // ç”¨äºå¤šç›®æ ‡åŒ¹é…æ—¶é€‰æ‹©
        });
      }
      
      return patches;
    };

    const generateRaw = (patch) => {
      if (patch.operation === 'CREATE') {
        return `<<<FIUP>>>
[FILE]: ${patch.file}
[OP]: ${patch.operation}
[CONTENT]
${patch.content}
<<<END>>>`;
      }
      
      let raw = `<<<FIUP>>>
[FILE]: ${patch.file}
[OP]: ${patch.operation}
[ANCHOR]
${patch.anchor}`;
      
      if (patch.operation !== 'DELETE') {
        raw += `
[CONTENT]
${patch.content}`;
      }
      
      raw += `
<<<END>>>`;
      
      return raw;
    };

    // ============================================================================
    // æ”¹è¿›çš„åŒ¹é…å‡½æ•° - æ”¯æŒå¤šç›®æ ‡å®šä½
    // ============================================================================
    
    const normalizeWhitespace = (text) => {
      return text
        .split('\n')
        .map(line => line.trimEnd())
        .join('\n')
        .replace(/[ \t]+/g, ' ');
    };

    // æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…ä½ç½®
    const findAllMatches = (content, anchor, fuzzyMatch = false) => {
      const normalizedContent = content.replace(/\r\n/g, '\n');
      const normalizedAnchor = anchor.replace(/\r\n/g, '\n');
      
      let searchContent = normalizedContent;
      let searchAnchor = normalizedAnchor;
      
      if (fuzzyMatch) {
        searchContent = normalizeWhitespace(normalizedContent);
        searchAnchor = normalizeWhitespace(normalizedAnchor);
      }
      
      const matches = [];
      let pos = 0;
      
      while ((pos = searchContent.indexOf(searchAnchor, pos)) !== -1) {
        // è®¡ç®—è¡Œå·
        const beforeText = normalizedContent.substring(0, pos);
        const line = beforeText.split('\n').length;
        
        // è·å–ä¸Šä¸‹æ–‡é¢„è§ˆ
        const contentLines = normalizedContent.split('\n');
        const startLine = Math.max(0, line - 2);
        const endLine = Math.min(contentLines.length, line + normalizedAnchor.split('\n').length + 1);
        const preview = contentLines.slice(startLine, endLine).join('\n');
        
        matches.push({
          position: pos,
          line,
          preview,
          startLine: startLine + 1,
          endLine
        });
        
        pos += 1; // ç»§ç»­æœç´¢ä¸‹ä¸€ä¸ªåŒ¹é…
      }
      
      return matches;
    };

    // æŸ¥æ‰¾ç›¸ä¼¼å†…å®¹ï¼ˆé¦–è¡ŒåŒ¹é…ï¼‰
    const findSimilarContent = (content, anchor, maxResults = 5) => {
      const anchorLines = anchor.split('\n').filter(l => l.trim());
      if (anchorLines.length === 0) return [];
      
      const firstLine = anchorLines[0].trim();
      const contentLines = content.split('\n');
      const matches = [];
      
      for (let i = 0; i < contentLines.length; i++) {
        if (contentLines[i].trim() === firstLine) {
          matches.push({
            line: i + 1,
            preview: contentLines.slice(i, i + anchorLines.length).join('\n')
          });
        }
      }
      
      return matches.slice(0, maxResults);
    };

    // åº”ç”¨è¡¥ä¸ï¼ˆæ”¯æŒæŒ‡å®šåŒ¹é…ç´¢å¼•ï¼‰
    const simulateApply = (content, patch, fuzzyMatch = false, matchIndex = null) => {
      if (patch.operation === 'CREATE') {
        return { 
          success: true, 
          message: 'æ–°å»ºæ–‡ä»¶', 
          result: patch.content,
          isCreate: true
        };
      }
      
      const normalizedContent = content.replace(/\r\n/g, '\n');
      const normalizedAnchor = patch.anchor.replace(/\r\n/g, '\n');
      
      let searchContent = normalizedContent;
      let searchAnchor = normalizedAnchor;
      
      if (fuzzyMatch) {
        searchContent = normalizeWhitespace(normalizedContent);
        searchAnchor = normalizeWhitespace(normalizedAnchor);
      }
      
      // æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…
      const allMatches = findAllMatches(normalizedContent, normalizedAnchor, fuzzyMatch);
      
      if (allMatches.length === 0) {
        const similar = findSimilarContent(normalizedContent, normalizedAnchor);
        return { 
          success: false, 
          message: 'é”šç‚¹æœªæ‰¾åˆ°', 
          result: content,
          similar: similar.length > 0 ? similar : null,
          debugInfo: {
            anchorLength: normalizedAnchor.length,
            hasTab: normalizedAnchor.includes('\t'),
            hasTrailingSpace: /[ \t]$/.test(normalizedAnchor),
            lineCount: normalizedAnchor.split('\n').length
          }
        };
      }
      
      // å¤šå¤„åŒ¹é…
      if (allMatches.length > 1) {
        // å¦‚æœæŒ‡å®šäº†åŒ¹é…ç´¢å¼•ï¼Œä½¿ç”¨è¯¥ä½ç½®
        if (matchIndex !== null && matchIndex >= 0 && matchIndex < allMatches.length) {
          // ä½¿ç”¨æŒ‡å®šçš„åŒ¹é…ä½ç½®ç»§ç»­
        } else {
          // è¿”å›æ‰€æœ‰åŒ¹é…ä½ç½®ä¾›ç”¨æˆ·é€‰æ‹©
          return { 
            success: false, 
            message: `é”šç‚¹åŒ¹é…åˆ° ${allMatches.length} å¤„`, 
            result: content,
            multipleMatches: allMatches,
            matchCount: allMatches.length
          };
        }
      }
      
      // ç¡®å®šè¦ä½¿ç”¨çš„åŒ¹é…ä½ç½®
      const targetMatch = matchIndex !== null ? allMatches[matchIndex] : allMatches[0];
      const pos = targetMatch.position;
      
      const before = normalizedContent.slice(0, pos);
      const after = normalizedContent.slice(pos + normalizedAnchor.length);
      let result;
      
      switch (patch.operation) {
        case 'REPLACE':
          result = before + patch.content + after;
          break;
        case 'INSERT_AFTER':
          const sep1 = normalizedAnchor.endsWith('\n') ? '' : '\n';
          result = before + normalizedAnchor + sep1 + patch.content + after;
          break;
        case 'INSERT_BEFORE':
          const sep2 = patch.content.endsWith('\n') ? '' : '\n';
          result = before + patch.content + sep2 + normalizedAnchor + after;
          break;
        case 'DELETE':
          result = before + after;
          break;
        default:
          result = content;
      }
      
      const line = before.split('\n').length;
      return { 
        success: true, 
        message: `${fuzzyMatch ? 'å®½æ¾åŒ¹é…' : 'ç²¾ç¡®åŒ¹é…'} @ è¡Œ ${line}${matchIndex !== null ? ` (ç¬¬${matchIndex + 1}å¤„)` : ''}`, 
        result, 
        line,
        fuzzyMatched: fuzzyMatch,
        usedMatchIndex: matchIndex
      };
    };

    const validatePatch = (patch) => {
      const errors = [];
      const warnings = [];
      
      if (!patch.file) errors.push('æ–‡ä»¶è·¯å¾„ä¸ºç©º');
      
      if (patch.operation === 'CREATE') {
        if (!patch.content?.trim()) errors.push('CREATE æ“ä½œä½†å†…å®¹ä¸ºç©º');
      } else {
        if (!patch.anchor?.trim()) errors.push('é”šç‚¹å†…å®¹ä¸ºç©º');
        
        const anchorLines = patch.anchor?.trim().split('\n').length || 0;
        if (anchorLines < 2) warnings.push(`é”šç‚¹ä»… ${anchorLines} è¡Œï¼Œå»ºè®® 3-6 è¡Œ`);
        
        if (patch.operation !== 'DELETE' && !patch.content?.trim()) {
          errors.push('é DELETE/CREATE æ“ä½œä½†å†…å®¹ä¸ºç©º');
        }
        
        if (patch.anchor?.includes('\t')) warnings.push('é”šç‚¹åŒ…å«Tabå­—ç¬¦');
        if (/[ \t]$/.test(patch.anchor)) warnings.push('é”šç‚¹åŒ…å«è¡Œå°¾ç©ºç™½');
      }
      
      if (patch.anchor?.includes('...') || patch.anchor?.includes('# ...')) {
        warnings.push('é”šç‚¹ä¸­åŒ…å« "..."');
      }
      
      return { valid: errors.length === 0, errors, warnings };
    };

    const opColors = {
      REPLACE: { bg: 'bg-blue-500/10', text: 'text-blue-400', border: 'border-blue-500/30' },
      INSERT_AFTER: { bg: 'bg-green-500/10', text: 'text-green-400', border: 'border-green-500/30' },
      INSERT_BEFORE: { bg: 'bg-emerald-500/10', text: 'text-emerald-400', border: 'border-emerald-500/30' },
      DELETE: { bg: 'bg-red-500/10', text: 'text-red-400', border: 'border-red-500/30' },
      CREATE: { bg: 'bg-purple-500/10', text: 'text-purple-400', border: 'border-purple-500/30' }
    };

    const operations = ['REPLACE', 'INSERT_AFTER', 'INSERT_BEFORE', 'DELETE', 'CREATE'];

    const visualizeWhitespace = (text) => {
      if (!text) return null;
      return text.split('').map((char, idx) => {
        if (char === ' ') return <span key={idx} className="space">Â·</span>;
        if (char === '\t') return <span key={idx} className="tab">â†’   </span>;
        return char;
      });
    };

    // ============================================================================
    // PatchCard ç»„ä»¶ - æ”¯æŒå¢é‡å†…å®¹å’Œå¤šç›®æ ‡é€‰æ‹©
    // ============================================================================
    const PatchCard = ({ 
      patch, 
      index, 
      expanded, 
      onToggle, 
      onDelete, 
      onUpdate, 
      fileContent,        // åŸå§‹æ–‡ä»¶å†…å®¹
      accumulatedContent, // ç´¯ç§¯å†…å®¹ï¼ˆåº”ç”¨å‰åºè¡¥ä¸åï¼‰
      fuzzyMatch,
      isIncremental       // æ˜¯å¦åŸºäºå¢é‡å†…å®¹åŒ¹é…
    }) => {
      const [isEditing, setIsEditing] = useState(false);
      const [editData, setEditData] = useState({
        file: patch.file,
        operation: patch.operation,
        anchor: patch.anchor,
        content: patch.content
      });
      const [showWhitespace, setShowWhitespace] = useState(false);
      const [showDebug, setShowDebug] = useState(false);

      const validation = useMemo(() => validatePatch(patch), [patch]);
      
      // ä½¿ç”¨ç´¯ç§¯å†…å®¹è¿›è¡ŒåŒ¹é…ï¼ˆæ”¯æŒå¢é‡è¡¥ä¸ï¼‰
      const effectiveContent = accumulatedContent || fileContent;
      
      const applyResult = useMemo(() => {
        if (patch.operation === 'CREATE') {
          return simulateApply('', patch, false);
        }
        if (!effectiveContent) return null;
        
        // å…ˆç”¨ç´¯ç§¯å†…å®¹å°è¯•ç²¾ç¡®åŒ¹é…
        const exactResult = simulateApply(effectiveContent, patch, false, patch.selectedMatchIndex);
        if (exactResult.success) {
          return { ...exactResult, usedAccumulated: !!accumulatedContent };
        }
        
        // ç²¾ç¡®åŒ¹é…å¤±è´¥ï¼Œå°è¯•å®½æ¾åŒ¹é…
        if (fuzzyMatch) {
          const fuzzyResult = simulateApply(effectiveContent, patch, true, patch.selectedMatchIndex);
          if (fuzzyResult.success) {
            return { ...fuzzyResult, wasFuzzy: true, usedAccumulated: !!accumulatedContent };
          }
          return { ...fuzzyResult, usedAccumulated: !!accumulatedContent };
        }
        
        return { ...exactResult, usedAccumulated: !!accumulatedContent };
      }, [effectiveContent, patch, fuzzyMatch, accumulatedContent]);
      
      const color = opColors[patch.operation] || opColors.REPLACE;

      const handleStartEdit = (e) => {
        e.stopPropagation();
        setEditData({
          file: patch.file,
          operation: patch.operation,
          anchor: patch.anchor,
          content: patch.content
        });
        setIsEditing(true);
      };

      const handleCancelEdit = (e) => {
        e.stopPropagation();
        setIsEditing(false);
      };

      const handleSaveEdit = (e) => {
        e.stopPropagation();
        const updatedPatch = {
          ...patch,
          ...editData,
          raw: generateRaw(editData),
          selectedMatchIndex: null // é‡ç½®é€‰æ‹©
        };
        onUpdate(updatedPatch);
        setIsEditing(false);
      };

      const handleSelectMatch = (matchIdx) => {
        onUpdate({ ...patch, selectedMatchIndex: matchIdx });
      };

      const handleKeyDown = (e) => {
        if (e.key === 'Tab') {
          e.preventDefault();
          const target = e.target;
          const start = target.selectionStart;
          const end = target.selectionEnd;
          const value = target.value;
          const newValue = value.substring(0, start) + '  ' + value.substring(end);
          
          const fieldName = target.dataset.field;
          if (fieldName) {
            setEditData(prev => ({ ...prev, [fieldName]: newValue }));
            setTimeout(() => {
              target.selectionStart = target.selectionEnd = start + 2;
            }, 0);
          }
        }
      };
      
      return (
        <div className={`rounded-xl border ${color.border} ${color.bg} overflow-hidden transition-all duration-200`}>
          <div 
            className="flex items-center gap-3 p-4 cursor-pointer hover:bg-white/5 transition-colors"
            onClick={onToggle}
          >
            <div className="text-gray-500">
              {expanded ? <Icons.ChevronDown /> : <Icons.ChevronRight />}
            </div>
            
            <span className="text-gray-600 text-xs font-mono w-6">#{index + 1}</span>
            
            {isEditing ? (
              <select
                value={editData.operation}
                onChange={(e) => setEditData(prev => ({ ...prev, operation: e.target.value }))}
                onClick={(e) => e.stopPropagation()}
                className={`px-2 py-0.5 rounded text-xs font-mono font-medium ${color.text} bg-black/30 border ${color.border}`}
              >
                {operations.map(op => <option key={op} value={op}>{op}</option>)}
              </select>
            ) : (
              <span className={`px-2 py-0.5 rounded text-xs font-mono font-medium ${color.text} ${color.bg} border ${color.border}`}>
                {patch.operation}
              </span>
            )}
            
            {isEditing ? (
              <input
                type="text"
                value={editData.file}
                onChange={(e) => setEditData(prev => ({ ...prev, file: e.target.value }))}
                onClick={(e) => e.stopPropagation()}
                className="text-gray-300 font-mono text-sm flex-1 bg-black/30 border border-gray-600 rounded px-2 py-0.5"
                placeholder="æ–‡ä»¶è·¯å¾„"
              />
            ) : (
              <span className="text-gray-300 font-mono text-sm flex-1 truncate">{patch.file}</span>
            )}
            
            <div className="flex items-center gap-2">
              {!isEditing && (
                <>
                  {applyResult?.usedAccumulated && applyResult?.success && (
                    <span className="flex items-center gap-1 text-cyan-400 text-xs" title="åŸºäºå¢é‡å†…å®¹åŒ¹é…">
                      <Icons.Layers />
                    </span>
                  )}
                  {applyResult?.wasFuzzy && (
                    <span className="flex items-center gap-1 text-yellow-500 text-xs" title="å®½æ¾åŒ¹é…">
                      <Icons.Zap />
                    </span>
                  )}
                  {patch.selectedMatchIndex !== null && (
                    <span className="flex items-center gap-1 text-orange-400 text-xs" title={`å·²é€‰æ‹©ç¬¬${patch.selectedMatchIndex + 1}å¤„åŒ¹é…`}>
                      <Icons.Target />
                    </span>
                  )}
                  {validation.warnings.length > 0 && (
                    <span className="text-yellow-500"><Icons.AlertTriangle /></span>
                  )}
                  {applyResult?.success === true && (
                    <span className="text-green-500"><Icons.CheckCircle /></span>
                  )}
                  {applyResult?.success === false && (
                    <span className="text-red-500"><Icons.XCircle /></span>
                  )}
                </>
              )}
            </div>
            
            {isEditing ? (
              <div className="flex items-center gap-1">
                <button onClick={handleSaveEdit} className="p-1.5 rounded-lg bg-green-500/20 hover:bg-green-500/30 text-green-400"><Icons.Save /></button>
                <button onClick={handleCancelEdit} className="p-1.5 rounded-lg bg-gray-700/50 hover:bg-gray-700 text-gray-400"><Icons.X /></button>
              </div>
            ) : (
              <div className="flex items-center gap-1">
                <button onClick={handleStartEdit} className="p-1.5 rounded-lg hover:bg-violet-500/20 text-gray-500 hover:text-violet-400"><Icons.Edit /></button>
                <button onClick={(e) => { e.stopPropagation(); onDelete(); }} className="p-1.5 rounded-lg hover:bg-red-500/20 text-gray-500 hover:text-red-400"><Icons.Trash2 /></button>
              </div>
            )}
          </div>
          
          {expanded && (
            <div className="px-4 pb-4 space-y-4">
              {!isEditing && (!validation.valid || validation.warnings.length > 0) && (
                <div className="space-y-1">
                  {validation.errors.map((err, i) => (
                    <div key={i} className="flex items-center gap-2 text-sm text-red-400"><Icons.XCircle /> {err}</div>
                  ))}
                  {validation.warnings.map((warn, i) => (
                    <div key={i} className="flex items-center gap-2 text-sm text-yellow-500"><Icons.AlertTriangle /> {warn}</div>
                  ))}
                </div>
              )}
              
              {!isEditing && applyResult && (
                <div>
                  <div className={`flex items-center gap-2 text-sm ${applyResult.success ? (applyResult.wasFuzzy ? 'text-yellow-400' : 'text-green-400') : 'text-red-400'}`}>
                    {applyResult.success ? <Icons.CheckCircle /> : <Icons.XCircle />}
                    {applyResult.message}
                    {applyResult.usedAccumulated && applyResult.success && (
                      <span className="text-xs text-cyan-400 ml-2">(å¢é‡æ¨¡å¼)</span>
                    )}
                  </div>
                  
                  {/* å¤šç›®æ ‡åŒ¹é…é€‰æ‹©å™¨ */}
                  {!applyResult.success && applyResult.multipleMatches && (
                    <div className="mt-3 p-4 bg-orange-500/10 rounded-lg border border-orange-500/30">
                      <div className="flex items-center gap-2 text-sm font-medium text-orange-300 mb-3">
                        <Icons.Target />
                        æ‰¾åˆ° {applyResult.matchCount} å¤„åŒ¹é…ï¼Œè¯·é€‰æ‹©è¦åº”ç”¨çš„ä½ç½®ï¼š
                      </div>
                      <div className="space-y-2 max-h-64 overflow-y-auto">
                        {applyResult.multipleMatches.map((match, idx) => (
                          <div 
                            key={idx}
                            className={`p-3 rounded-lg border cursor-pointer transition-all ${
                              patch.selectedMatchIndex === idx 
                                ? 'bg-orange-500/20 border-orange-500/50' 
                                : 'bg-black/20 border-gray-700 hover:border-orange-500/30'
                            }`}
                            onClick={(e) => { e.stopPropagation(); handleSelectMatch(idx); }}
                          >
                            <div className="flex items-center gap-2 mb-2">
                              <Icons.MapPin />
                              <span className="text-sm font-medium text-orange-300">
                                ä½ç½® {idx + 1}: è¡Œ {match.line}
                              </span>
                              {patch.selectedMatchIndex === idx && (
                                <span className="text-xs bg-orange-500/30 px-2 py-0.5 rounded text-orange-200">å·²é€‰æ‹©</span>
                              )}
                            </div>
                            <pre className="text-xs text-gray-400 bg-black/30 rounded p-2 overflow-x-auto whitespace-pre font-mono">
                              {match.preview}
                            </pre>
                          </div>
                        ))}
                      </div>
                      <div className="mt-3 text-xs text-orange-200/70">
                        ğŸ’¡ ç‚¹å‡»é€‰æ‹©è¦åº”ç”¨è¡¥ä¸çš„ä½ç½®ï¼Œæˆ–ä¿®æ”¹é”šç‚¹ä½¿å…¶æ›´åŠ å”¯ä¸€
                      </div>
                    </div>
                  )}
                  
                  {/* è°ƒè¯•ä¿¡æ¯ */}
                  {!applyResult.success && applyResult.debugInfo && !applyResult.multipleMatches && (
                    <div className="mt-2 p-3 bg-black/30 rounded-lg border border-gray-700">
                      <div className="flex items-center justify-between mb-2">
                        <span className="text-xs font-medium text-gray-400">è°ƒè¯•ä¿¡æ¯</span>
                        <button onClick={(e) => { e.stopPropagation(); setShowDebug(!showDebug); }} className="text-xs text-gray-500 hover:text-gray-300">
                          {showDebug ? 'éšè—' : 'æ˜¾ç¤º'}
                        </button>
                      </div>
                      {showDebug && (
                        <div className="space-y-1 text-xs text-gray-500">
                          <div>é”šç‚¹é•¿åº¦: {applyResult.debugInfo.anchorLength} å­—ç¬¦</div>
                          <div>åŒ…å«Tab: {applyResult.debugInfo.hasTab ? 'æ˜¯ âš ï¸' : 'å¦'}</div>
                          <div>è¡Œå°¾ç©ºç™½: {applyResult.debugInfo.hasTrailingSpace ? 'æ˜¯ âš ï¸' : 'å¦'}</div>
                          <div>è¡Œæ•°: {applyResult.debugInfo.lineCount}</div>
                        </div>
                      )}
                    </div>
                  )}
                  
                  {/* ç›¸ä¼¼å†…å®¹æç¤º */}
                  {!applyResult.success && applyResult.similar && !applyResult.multipleMatches && (
                    <div className="mt-2 p-3 bg-blue-500/10 rounded-lg border border-blue-500/30">
                      <div className="text-xs font-medium text-blue-400 mb-2">é¦–è¡Œç›¸ä¼¼å†…å®¹ï¼š</div>
                      {applyResult.similar.map((sim, idx) => (
                        <div key={idx} className="mt-2 text-xs">
                          <div className="text-gray-400 mb-1">è¡Œ {sim.line}:</div>
                          <pre className="bg-black/30 rounded p-2 text-gray-300 overflow-x-auto font-mono text-xs">{sim.preview}</pre>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}
              
              {(isEditing ? editData.operation !== 'CREATE' : patch.operation !== 'CREATE') && (
                <div>
                  <div className="text-xs text-gray-500 mb-1.5 font-medium flex items-center justify-between">
                    <span>ANCHOR</span>
                    {!isEditing && (
                      <button onClick={(e) => { e.stopPropagation(); setShowWhitespace(!showWhitespace); }} className="flex items-center gap-1 text-gray-600 hover:text-gray-400">
                        {showWhitespace ? <Icons.EyeOff /> : <Icons.Eye />}
                        <span className="text-xs">{showWhitespace ? 'éšè—ç©ºç™½' : 'æ˜¾ç¤ºç©ºç™½'}</span>
                      </button>
                    )}
                  </div>
                  {isEditing ? (
                    <textarea
                      value={editData.anchor}
                      onChange={(e) => setEditData(prev => ({ ...prev, anchor: e.target.value }))}
                      onKeyDown={handleKeyDown}
                      data-field="anchor"
                      className="edit-area w-full bg-black/30 rounded-lg p-3 text-sm text-gray-300 font-mono leading-relaxed whitespace-pre border border-gray-600 focus:border-violet-500 resize-y min-h-[100px]"
                    />
                  ) : (
                    <pre className={`bg-black/30 rounded-lg p-3 text-sm text-gray-300 overflow-x-auto font-mono leading-relaxed ${showWhitespace ? 'whitespace-visible' : 'whitespace-pre'}`}>
                      {showWhitespace ? visualizeWhitespace(patch.anchor) : patch.anchor}
                    </pre>
                  )}
                </div>
              )}
              
              {(isEditing ? (editData.operation !== 'DELETE' || editData.content) : patch.content) && (
                <div>
                  <div className="text-xs text-gray-500 mb-1.5 font-medium">CONTENT</div>
                  {isEditing ? (
                    <textarea
                      value={editData.content}
                      onChange={(e) => setEditData(prev => ({ ...prev, content: e.target.value }))}
                      onKeyDown={handleKeyDown}
                      data-field="content"
                      className="edit-area w-full bg-black/30 rounded-lg p-3 text-sm text-green-300 font-mono leading-relaxed whitespace-pre border border-gray-600 focus:border-violet-500 resize-y min-h-[100px]"
                    />
                  ) : (
                    <pre className="bg-black/30 rounded-lg p-3 text-sm text-green-300 overflow-x-auto font-mono leading-relaxed whitespace-pre">{patch.content}</pre>
                  )}
                </div>
              )}

              {isEditing && (
                <div className="flex items-center gap-2 pt-2 border-t border-gray-700/50">
                  <button onClick={handleSaveEdit} className="flex items-center gap-2 px-4 py-2 rounded-lg bg-green-500/20 hover:bg-green-500/30 text-green-400 text-sm font-medium">
                    <Icons.Save /> ä¿å­˜ä¿®æ”¹
                  </button>
                  <button onClick={handleCancelEdit} className="flex items-center gap-2 px-4 py-2 rounded-lg bg-gray-700/50 hover:bg-gray-700 text-gray-400 text-sm font-medium">
                    <Icons.X /> å–æ¶ˆ
                  </button>
                </div>
              )}
            </div>
          )}
        </div>
      );
    };

    const DiffView = ({ original, modified }) => {
      const diff = useMemo(() => {
        if (!original && !modified) return [];
        const oldLines = (original || '').split('\n');
        const newLines = (modified || '').split('\n');
        const result = [];
        
        let i = 0, j = 0;
        while (i < oldLines.length || j < newLines.length) {
          if (i < oldLines.length && j < newLines.length && oldLines[i] === newLines[j]) {
            result.push({ type: 'same', content: oldLines[i], lineOld: i + 1, lineNew: j + 1 });
            i++; j++;
          } else if (j < newLines.length && (i >= oldLines.length || !oldLines.includes(newLines[j]))) {
            result.push({ type: 'add', content: newLines[j], lineNew: j + 1 });
            j++;
          } else if (i < oldLines.length) {
            result.push({ type: 'del', content: oldLines[i], lineOld: i + 1 });
            i++;
          }
        }
        return result;
      }, [original, modified]);
      
      return (
        <div className="bg-gray-900/50 rounded-xl overflow-hidden border border-gray-700/50">
          <div className="overflow-x-auto max-h-96">
            <pre className="text-sm font-mono">
              {diff.map((line, idx) => (
                <div key={idx} className={`px-4 py-0.5 flex ${line.type === 'add' ? 'bg-green-500/10 text-green-300' : line.type === 'del' ? 'bg-red-500/10 text-red-300' : 'text-gray-400'}`}>
                  <span className="w-12 text-gray-600 select-none text-right pr-2">{line.lineOld || ''}</span>
                  <span className="w-12 text-gray-600 select-none text-right pr-2">{line.lineNew || ''}</span>
                  <span className="w-6 select-none">{line.type === 'add' ? '+' : line.type === 'del' ? '-' : ' '}</span>
                  <span className="flex-1 whitespace-pre">{line.content}</span>
                </div>
              ))}
            </pre>
          </div>
        </div>
      );
    };

    const Toast = ({ message, type, onClose }) => {
      React.useEffect(() => {
        const timer = setTimeout(onClose, 3000);
        return () => clearTimeout(timer);
      }, [onClose]);

      const colors = {
        success: 'bg-green-500/20 border-green-500/50 text-green-300',
        error: 'bg-red-500/20 border-red-500/50 text-red-300',
        info: 'bg-blue-500/20 border-blue-500/50 text-blue-300'
      };

      return (
        <div className={`fixed bottom-4 right-4 px-4 py-3 rounded-lg border ${colors[type]} z-50`}>{message}</div>
      );
    };

    // ============================================================================
    // ä¸»åº”ç”¨ç»„ä»¶
    // ============================================================================
    function FIUPApp() {
      const [patchText, setPatchText] = useState('');
      const [patches, setPatches] = useState([]);
      const [files, setFiles] = useState({});
      const [expandedPatch, setExpandedPatch] = useState(null);
      const [activeTab, setActiveTab] = useState('input');
      const [previewFile, setPreviewFile] = useState(null);
      const [toast, setToast] = useState(null);
      const [isDragging, setIsDragging] = useState(false);
      const [fuzzyMatch, setFuzzyMatch] = useState(true);
      const [incrementalMode, setIncrementalMode] = useState(true); // æ–°å¢ï¼šå¢é‡æ¨¡å¼å¼€å…³
      
      const showToast = (message, type = 'info') => setToast({ message, type });
      
      // ============================================================================
      // è®¡ç®—æ¯ä¸ªè¡¥ä¸çš„ç´¯ç§¯å†…å®¹ï¼ˆå…³é”®ä¿®å¤ï¼‰
      // ============================================================================
      const accumulatedContents = useMemo(() => {
        if (!incrementalMode) return {};
        
        const result = {};
        const fileContents = {}; // æ¯ä¸ªæ–‡ä»¶çš„å½“å‰ç´¯ç§¯å†…å®¹
        
        patches.forEach((patch, index) => {
          const fileName = patch.file;
          const shortName = fileName.split('/').pop();
          
          // è·å–åŸå§‹æ–‡ä»¶å†…å®¹
          const originalContent = files[fileName] || files[shortName] || '';
          
          // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªæ“ä½œè¯¥æ–‡ä»¶çš„è¡¥ä¸ï¼Œä½¿ç”¨åŸå§‹å†…å®¹
          if (!fileContents[fileName]) {
            fileContents[fileName] = originalContent;
          }
          
          // CREATE æ“ä½œç‰¹æ®Šå¤„ç†
          if (patch.operation === 'CREATE') {
            result[patch.id] = '';
            fileContents[fileName] = patch.content;
            return;
          }
          
          // è®°å½•å½“å‰è¡¥ä¸åº”è¯¥ä½¿ç”¨çš„ç´¯ç§¯å†…å®¹
          result[patch.id] = fileContents[fileName];
          
          // åº”ç”¨å½“å‰è¡¥ä¸ï¼Œæ›´æ–°ç´¯ç§¯å†…å®¹
          const applyResult = simulateApply(fileContents[fileName], patch, fuzzyMatch, patch.selectedMatchIndex);
          if (applyResult.success) {
            fileContents[fileName] = applyResult.result;
          }
        });
        
        return result;
      }, [patches, files, fuzzyMatch, incrementalMode]);
      
      const handleParse = useCallback(() => {
        const parsed = parseFIUP(patchText);
        setPatches(parsed);
        if (parsed.length > 0) {
          setExpandedPatch(parsed[0].id);
          setActiveTab('patches');
          showToast(`æˆåŠŸè§£æ ${parsed.length} ä¸ªè¡¥ä¸`, 'success');
        } else {
          showToast('æœªæ‰¾åˆ°æœ‰æ•ˆçš„ FIUP è¡¥ä¸', 'error');
        }
      }, [patchText]);
      
      const handleFileUpload = useCallback((e) => {
        const uploadedFiles = Array.from(e.target.files);
        uploadedFiles.forEach(file => {
          const reader = new FileReader();
          reader.onload = (event) => {
            setFiles(prev => ({ ...prev, [file.name]: event.target.result }));
            showToast(`å·²åŠ è½½æ–‡ä»¶: ${file.name}`, 'success');
          };
          reader.readAsText(file);
        });
        e.target.value = '';
      }, []);

      const handleDrop = useCallback((e) => {
        e.preventDefault();
        setIsDragging(false);
        Array.from(e.dataTransfer.files).forEach(file => {
          const reader = new FileReader();
          reader.onload = (event) => setFiles(prev => ({ ...prev, [file.name]: event.target.result }));
          reader.readAsText(file);
        });
        showToast(`å·²åŠ è½½æ–‡ä»¶`, 'success');
      }, []);

      const handleDeleteFile = useCallback((fileName) => {
        setFiles(prev => {
          const newFiles = { ...prev };
          delete newFiles[fileName];
          return newFiles;
        });
        showToast(`å·²ç§»é™¤æ–‡ä»¶: ${fileName}`, 'info');
      }, []);
      
      const handleDeletePatch = useCallback((id) => {
        setPatches(prev => prev.filter(p => p.id !== id));
      }, []);

      const handleUpdatePatch = useCallback((updatedPatch) => {
        setPatches(prev => prev.map(p => p.id === updatedPatch.id ? updatedPatch : p));
        showToast('è¡¥ä¸å·²æ›´æ–°', 'success');
      }, []);
      
      const handlePreview = useCallback((fileName) => {
        const filePatches = patches.filter(p => p.file === fileName || p.file.endsWith('/' + fileName));
        const originalContent = files[fileName] || '';
        let content = originalContent;
        
        for (const patch of filePatches) {
          const result = simulateApply(content, patch, fuzzyMatch, patch.selectedMatchIndex);
          if (result.success) content = result.result;
        }
        
        setPreviewFile({ name: fileName, original: originalContent, modified: content });
      }, [patches, files, fuzzyMatch]);

      const handlePreviewCreate = useCallback((patch) => {
        setPreviewFile({ name: patch.file, original: '', modified: patch.content, isCreate: true });
      }, []);

      const handleApplyAndDownload = useCallback((fileName) => {
        const filePatches = patches.filter(p => p.file === fileName || p.file.endsWith('/' + fileName));
        
        const createPatch = filePatches.find(p => p.operation === 'CREATE');
        if (createPatch) {
          const blob = new Blob([createPatch.content], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName.split('/').pop();
          a.click();
          URL.revokeObjectURL(url);
          showToast(`å·²åˆ›å»ºå¹¶å¯¼å‡º: ${fileName}`, 'success');
          return;
        }
        
        const originalContent = files[fileName] || files[Object.keys(files).find(f => fileName.endsWith(f))] || '';
        if (!originalContent) {
          showToast(`è¯·å…ˆä¸Šä¼ æ–‡ä»¶: ${fileName}`, 'error');
          return;
        }
        
        let content = originalContent;
        let successCount = 0;
        
        for (const patch of filePatches) {
          const result = simulateApply(content, patch, fuzzyMatch, patch.selectedMatchIndex);
          if (result.success) {
            content = result.result;
            successCount++;
          }
        }
        
        if (successCount === 0) {
          showToast('æ²¡æœ‰æˆåŠŸåº”ç”¨çš„è¡¥ä¸', 'error');
          return;
        }
        
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName.split('/').pop();
        a.click();
        URL.revokeObjectURL(url);
        showToast(`å·²å¯¼å‡º: ${fileName} (${successCount}/${filePatches.length} è¡¥ä¸æˆåŠŸ)`, 'success');
      }, [patches, files, fuzzyMatch]);
      
      const handleCopyPatches = useCallback(() => {
        const text = patches.map(p => p.raw).join('\n\n');
        navigator.clipboard.writeText(text);
        showToast('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
      }, [patches]);

      const handleExport = useCallback(() => {
        if (!previewFile) return;
        const blob = new Blob([previewFile.modified], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = previewFile.name.split('/').pop();
        a.click();
        URL.revokeObjectURL(url);
        showToast(`å·²å¯¼å‡º: ${previewFile.name}`, 'success');
      }, [previewFile]);
      
      const stats = useMemo(() => {
        const byOp = { REPLACE: 0, INSERT_AFTER: 0, INSERT_BEFORE: 0, DELETE: 0, CREATE: 0 };
        patches.forEach(p => { if (byOp.hasOwnProperty(p.operation)) byOp[p.operation]++; });
        return { byOp, total: patches.length };
      }, [patches]);

      const createFiles = useMemo(() => patches.filter(p => p.operation === 'CREATE').map(p => p.file), [patches]);

      return (
        <div 
          className={`min-h-screen bg-gradient-to-br from-gray-950 via-gray-900 to-gray-950 text-white ${isDragging ? 'ring-2 ring-inset ring-violet-500' : ''}`}
          onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
          onDragLeave={(e) => { e.preventDefault(); setIsDragging(false); }}
          onDrop={handleDrop}
        >
          {isDragging && (
            <div className="fixed inset-0 bg-violet-500/10 backdrop-blur-sm z-50 flex items-center justify-center pointer-events-none">
              <div className="bg-gray-900/90 border-2 border-dashed border-violet-500 rounded-2xl p-12 text-center">
                <Icons.Upload />
                <p className="text-xl font-medium text-white mt-4">é‡Šæ”¾æ–‡ä»¶ä»¥ä¸Šä¼ </p>
              </div>
            </div>
          )}

          <header className="border-b border-gray-800/50 backdrop-blur-sm bg-gray-900/30 sticky top-0 z-10">
            <div className="max-w-6xl mx-auto px-4 sm:px-6 py-4 flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-violet-500 to-fuchsia-500 flex items-center justify-center">
                  <Icons.Code />
                </div>
                <div>
                  <h1 className="text-lg font-semibold">FIUP Tool v3.3</h1>
                  <p className="text-xs text-gray-500 hidden sm:block">å¢é‡è¡¥ä¸ + å¤šç›®æ ‡å®šä½</p>
                </div>
              </div>
              
              <div className="flex items-center gap-2">
                <button
                  onClick={() => setIncrementalMode(!incrementalMode)}
                  className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-medium transition-all ${
                    incrementalMode ? 'bg-cyan-500/20 text-cyan-400 border border-cyan-500/30' : 'bg-gray-800/50 text-gray-400 border border-gray-700'
                  }`}
                  title={incrementalMode ? "å¢é‡æ¨¡å¼ï¼šè¡¥ä¸åŸºäºå‰åºè¡¥ä¸çš„ç»“æœåŒ¹é…" : "ç‹¬ç«‹æ¨¡å¼ï¼šæ¯ä¸ªè¡¥ä¸ç‹¬ç«‹åŒ¹é…åŸå§‹æ–‡ä»¶"}
                >
                  <Icons.Layers />
                  <span className="hidden sm:inline">å¢é‡</span>
                </button>
                <button
                  onClick={() => setFuzzyMatch(!fuzzyMatch)}
                  className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-medium transition-all ${
                    fuzzyMatch ? 'bg-yellow-500/20 text-yellow-400 border border-yellow-500/30' : 'bg-gray-800/50 text-gray-400 border border-gray-700'
                  }`}
                  title={fuzzyMatch ? "å®½æ¾åŒ¹é…ï¼šå¿½ç•¥ç©ºç™½å·®å¼‚" : "ç²¾ç¡®åŒ¹é…"}
                >
                  <Icons.Zap />
                  <span className="hidden sm:inline">å®½æ¾</span>
                </button>
                <a href="https://github.com/Thankyou-Cheems/FIUP" target="_blank" className="p-2 rounded-lg hover:bg-gray-800 text-gray-400 hover:text-white">
                  <Icons.Github />
                </a>
              </div>
            </div>
          </header>
          
          <main className="max-w-7xl mx-auto px-4 sm:px-6 py-6 sm:py-8">
            {/* åŠŸèƒ½è¯´æ˜æ¨ªå¹… */}
            {(incrementalMode || fuzzyMatch) && (
              <div className="mb-6 p-4 bg-gradient-to-r from-cyan-500/10 to-yellow-500/10 border border-cyan-500/20 rounded-xl">
                <div className="flex items-start gap-3">
                  <div className="mt-0.5 flex gap-2">
                    {incrementalMode && <Icons.Layers />}
                    {fuzzyMatch && <Icons.Zap />}
                  </div>
                  <div className="flex-1 text-xs text-gray-300 space-y-1">
                    {incrementalMode && (
                      <p><span className="text-cyan-400 font-medium">å¢é‡æ¨¡å¼</span>ï¼šåç»­è¡¥ä¸åŸºäºå‰åºè¡¥ä¸ä¿®æ”¹åçš„å†…å®¹è¿›è¡ŒåŒ¹é…ï¼Œæ”¯æŒé“¾å¼ä¿®æ”¹</p>
                    )}
                    {fuzzyMatch && (
                      <p><span className="text-yellow-400 font-medium">å®½æ¾åŒ¹é…</span>ï¼šè‡ªåŠ¨å¿½ç•¥ç©ºç™½å­—ç¬¦å·®å¼‚ï¼ˆTab/ç©ºæ ¼ã€è¡Œå°¾ç©ºç™½ç­‰ï¼‰</p>
                    )}
                  </div>
                </div>
              </div>
            )}

            <div className="flex flex-col lg:flex-row gap-6">
              {/* å·¦ä¾§è¾¹æ  */}
              <div className="lg:w-72 xl:w-80 flex-shrink-0">
                <div className="lg:sticky lg:top-24 space-y-4">
                  <div 
                    className="p-4 rounded-xl border-2 border-dashed border-gray-700 hover:border-gray-600 bg-gray-800/30 cursor-pointer"
                    onClick={() => document.getElementById('file-input').click()}
                  >
                    <div className="text-center py-4">
                      <div className="mx-auto w-12 h-12 rounded-xl bg-gray-800 text-gray-500 flex items-center justify-center mb-3">
                        <Icons.Upload />
                      </div>
                      <p className="text-sm font-medium text-gray-300">æ‹–æ‹½æˆ–ç‚¹å‡»ä¸Šä¼ </p>
                      <p className="text-xs text-gray-500 mt-1">ä¸Šä¼ æºæ–‡ä»¶</p>
                    </div>
                    <input id="file-input" type="file" multiple className="hidden" onChange={handleFileUpload} />
                  </div>

                  <div className="bg-gray-800/30 rounded-xl border border-gray-700/50 overflow-hidden">
                    <div className="flex items-center justify-between px-4 py-3 border-b border-gray-700/50">
                      <h3 className="text-sm font-medium text-gray-300">æºæ–‡ä»¶ ({Object.keys(files).length})</h3>
                      {Object.keys(files).length > 0 && (
                        <button onClick={() => { setFiles({}); showToast('å·²æ¸…ç©º', 'info'); }} className="text-xs text-gray-500 hover:text-red-400">æ¸…ç©º</button>
                      )}
                    </div>
                    <div className="max-h-64 lg:max-h-96 overflow-y-auto">
                      {Object.keys(files).length === 0 ? (
                        <div className="px-4 py-8 text-center text-gray-600 text-sm">æš‚æ— æ–‡ä»¶</div>
                      ) : (
                        <div className="p-2 space-y-1">
                          {Object.entries(files).map(([name, content]) => {
                            const patchCount = patches.filter(p => p.file === name || p.file.endsWith('/' + name)).length;
                            return (
                              <div key={name} className="flex items-center gap-2 p-2 rounded-lg group hover:bg-gray-700/30">
                                <Icons.FileText />
                                <div className="flex-1 min-w-0">
                                  <div className="text-xs text-gray-300 truncate font-mono">{name}</div>
                                  <div className="text-xs text-gray-600">{content.split('\n').length} è¡Œ</div>
                                </div>
                                {patchCount > 0 && <span className="px-1.5 py-0.5 rounded bg-violet-500/20 text-violet-400 text-xs">{patchCount}</span>}
                                <button onClick={() => handleDeleteFile(name)} className="p-1 rounded opacity-0 group-hover:opacity-100 hover:bg-red-500/20 text-gray-500 hover:text-red-400">
                                  <Icons.Trash2 />
                                </button>
                              </div>
                            );
                          })}
                        </div>
                      )}
                    </div>
                  </div>

                  {createFiles.length > 0 && (
                    <div className="bg-purple-500/10 rounded-xl border border-purple-500/30 overflow-hidden">
                      <div className="px-4 py-3 border-b border-purple-500/20">
                        <h3 className="text-sm font-medium text-purple-300 flex items-center gap-2">
                          <Icons.FilePlus /> æ–°å»ºæ–‡ä»¶ ({createFiles.length})
                        </h3>
                      </div>
                      <div className="p-2 space-y-1">
                        {createFiles.map(fileName => (
                          <button key={fileName} onClick={() => handleApplyAndDownload(fileName)} className="w-full flex items-center gap-2 p-2 rounded-lg hover:bg-purple-500/20 text-left">
                            <Icons.Download />
                            <span className="text-xs text-purple-300 font-mono truncate">{fileName}</span>
                          </button>
                        ))}
                      </div>
                    </div>
                  )}

                  {patches.length > 0 && Object.keys(files).length > 0 && (
                    <div className="bg-gradient-to-br from-violet-500/10 to-fuchsia-500/10 rounded-xl border border-violet-500/20 p-3">
                      <div className="text-xs font-medium text-gray-400 mb-2">ä¸€é”®åº”ç”¨å¹¶ä¸‹è½½</div>
                      <div className="space-y-1">
                        {[...new Set(patches.filter(p => p.operation !== 'CREATE').map(p => p.file))].map(fileName => {
                          const hasFile = Object.keys(files).some(f => fileName === f || fileName.endsWith('/' + f));
                          if (!hasFile) return null;
                          return (
                            <button key={fileName} onClick={() => handleApplyAndDownload(fileName)} className="w-full flex items-center gap-2 px-3 py-2 rounded-lg bg-violet-500/20 hover:bg-violet-500/30 text-violet-300 text-sm font-medium text-left">
                              <Icons.Download />
                              <span className="truncate">{fileName.split('/').pop()}</span>
                            </button>
                          );
                        })}
                      </div>
                    </div>
                  )}
                </div>
              </div>

              {/* ä¸»å†…å®¹åŒº */}
              <div className="flex-1 min-w-0">
                <div className="flex gap-1 p-1 bg-gray-800/50 rounded-xl mb-6 w-fit">
                  {[
                    { id: 'input', label: 'è¾“å…¥è¡¥ä¸', icon: Icons.FileText },
                    { id: 'patches', label: `è¡¥ä¸åˆ—è¡¨ (${stats.total})`, icon: Icons.Code },
                    { id: 'preview', label: 'é¢„è§ˆå˜æ›´', icon: Icons.Eye }
                  ].map(tab => (
                    <button
                      key={tab.id}
                      onClick={() => setActiveTab(tab.id)}
                      className={`flex items-center gap-2 px-3 sm:px-4 py-2 rounded-lg text-sm font-medium transition-all ${
                        activeTab === tab.id ? 'bg-violet-500 text-white' : 'text-gray-400 hover:text-white hover:bg-gray-700/50'
                      }`}
                    >
                      <tab.icon />
                      <span className="hidden sm:inline">{tab.label}</span>
                    </button>
                  ))}
                </div>
            
                {activeTab === 'input' && (
                  <div className="space-y-4">
                    <div className="flex items-center justify-between flex-wrap gap-4">
                      <h2 className="text-lg font-medium">è¾“å…¥ FIUP v3.0 è¡¥ä¸</h2>
                      <button
                        onClick={handleParse}
                        disabled={!patchText.trim()}
                        className="flex items-center gap-2 px-4 py-2 rounded-lg bg-violet-500 hover:bg-violet-600 disabled:opacity-50 disabled:cursor-not-allowed font-medium"
                      >
                        <Icons.Play /> è§£æè¡¥ä¸
                      </button>
                    </div>
                    
                    <textarea
                      value={patchText}
                      onChange={(e) => setPatchText(e.target.value)}
                      placeholder={`ç²˜è´´ FIUP v3.0 è¡¥ä¸å†…å®¹...

v3.3 æ–°åŠŸèƒ½:
ğŸ”— å¢é‡è¡¥ä¸æ¨¡å¼ - åç»­è¡¥ä¸å¯åŸºäºå‰åºè¡¥ä¸ä¿®æ”¹åçš„å†…å®¹åŒ¹é…
ğŸ¯ å¤šç›®æ ‡å®šä½ - å½“é”šç‚¹åŒ¹é…å¤šå¤„æ—¶ï¼Œå¯é€‰æ‹©åº”ç”¨ä½ç½®
âš¡ å®½æ¾åŒ¹é… - è‡ªåŠ¨å¤„ç†ç©ºç™½å­—ç¬¦å·®å¼‚`}
                      className="w-full h-80 sm:h-96 bg-gray-900/50 border border-gray-700/50 rounded-xl p-4 font-mono text-sm text-gray-300 placeholder-gray-600 focus:outline-none focus:border-violet-500/50 resize-none"
                    />
                  </div>
                )}
            
                {activeTab === 'patches' && (
                  <div className="space-y-4">
                    {stats.total > 0 && (
                      <div className="flex items-center gap-4 p-4 bg-gray-800/30 rounded-xl flex-wrap">
                        <div className="flex items-center gap-4 sm:gap-6 flex-1 flex-wrap">
                          {Object.entries(stats.byOp).map(([op, count]) => count > 0 && (
                            <div key={op} className="flex items-center gap-2">
                              <span className={`w-2 h-2 rounded-full ${opColors[op]?.text.replace('text-', 'bg-')}`} />
                              <span className="text-sm text-gray-400">{op}</span>
                              <span className="text-sm font-medium">{count}</span>
                            </div>
                          ))}
                        </div>
                        <button onClick={handleCopyPatches} className="flex items-center gap-2 px-3 py-1.5 rounded-lg bg-gray-700 hover:bg-gray-600 text-sm">
                          <Icons.Copy /> å¤åˆ¶å…¨éƒ¨
                        </button>
                      </div>
                    )}

                    <div className="flex items-center gap-2 p-3 bg-violet-500/10 border border-violet-500/30 rounded-lg text-sm text-violet-300">
                      <Icons.Info />
                      <span>å±•å¼€è¡¥ä¸æŸ¥çœ‹è¯¦æƒ…ï¼Œå¤šç›®æ ‡åŒ¹é…æ—¶å¯é€‰æ‹©åº”ç”¨ä½ç½®</span>
                    </div>
                    
                    <div className="space-y-3">
                      {patches.length === 0 ? (
                        <div className="text-center py-16 text-gray-500">
                          <div className="mx-auto mb-4 opacity-30"><Icons.Code size={48} /></div>
                          <p>æš‚æ— è¡¥ä¸</p>
                        </div>
                      ) : (
                        patches.map((patch, index) => (
                          <PatchCard
                            key={patch.id}
                            patch={patch}
                            index={index}
                            expanded={expandedPatch === patch.id}
                            onToggle={() => setExpandedPatch(expandedPatch === patch.id ? null : patch.id)}
                            onDelete={() => handleDeletePatch(patch.id)}
                            onUpdate={handleUpdatePatch}
                            fileContent={files[patch.file] || files[patch.file.split('/').pop()]}
                            accumulatedContent={incrementalMode ? accumulatedContents[patch.id] : null}
                            fuzzyMatch={fuzzyMatch}
                            isIncremental={incrementalMode}
                          />
                        ))
                      )}
                    </div>
                  </div>
                )}
            
                {activeTab === 'preview' && (
                  <div className="space-y-4">
                    <div className="flex items-center gap-4 flex-wrap">
                      <h2 className="text-lg font-medium">é€‰æ‹©æ–‡ä»¶é¢„è§ˆ</h2>
                      {previewFile && (
                        <button onClick={handleExport} className="flex items-center gap-2 px-3 py-1.5 rounded-lg bg-green-500/20 hover:bg-green-500/30 text-green-400 text-sm ml-auto">
                          <Icons.Download /> å¯¼å‡ºæ–‡ä»¶
                        </button>
                      )}
                    </div>
                    
                    <div className="flex flex-wrap gap-2">
                      {Object.keys(files).length === 0 && createFiles.length === 0 ? (
                        <div className="w-full text-center py-8 border-2 border-dashed border-gray-700 rounded-xl">
                          <p className="text-gray-400">è¯·å…ˆä¸Šä¼ æºæ–‡ä»¶</p>
                        </div>
                      ) : (
                        <>
                          {Object.keys(files).map(name => {
                            const patchCount = patches.filter(p => p.file === name || p.file.endsWith('/' + name)).length;
                            return (
                              <button
                                key={name}
                                onClick={() => handlePreview(name)}
                                className={`flex items-center gap-2 px-4 py-2 rounded-lg border transition-colors ${
                                  previewFile?.name === name ? 'bg-violet-500/20 border-violet-500/50 text-violet-300' : 'bg-gray-800/50 border-gray-700/50 hover:border-gray-600'
                                }`}
                              >
                                <Icons.FileText />
                                <span className="text-sm">{name}</span>
                                {patchCount > 0 && <span className="px-1.5 py-0.5 rounded bg-violet-500/30 text-xs">{patchCount}</span>}
                              </button>
                            );
                          })}
                          {patches.filter(p => p.operation === 'CREATE').map(patch => (
                            <button
                              key={patch.file}
                              onClick={() => handlePreviewCreate(patch)}
                              className={`flex items-center gap-2 px-4 py-2 rounded-lg border ${
                                previewFile?.name === patch.file ? 'bg-purple-500/20 border-purple-500/50 text-purple-300' : 'bg-purple-500/10 border-purple-500/30 text-purple-400'
                              }`}
                            >
                              <Icons.FilePlus />
                              <span className="text-sm">{patch.file}</span>
                              <span className="px-1.5 py-0.5 rounded bg-purple-500/30 text-xs">NEW</span>
                            </button>
                          ))}
                        </>
                      )}
                    </div>
                    
                    {previewFile && (
                      <div className="space-y-2">
                        <div className="flex items-center justify-between">
                          <h3 className="text-sm font-medium text-gray-400">
                            {previewFile.isCreate ? 'æ–°æ–‡ä»¶é¢„è§ˆ' : 'å˜æ›´é¢„è§ˆ'}: {previewFile.name}
                          </h3>
                          {!previewFile.isCreate && (
                            <button onClick={() => handlePreview(previewFile.name)} className="flex items-center gap-1.5 px-2 py-1 rounded text-xs text-gray-400 hover:text-white">
                              <Icons.RefreshCw /> åˆ·æ–°
                            </button>
                          )}
                        </div>
                        <DiffView original={previewFile.original} modified={previewFile.modified} />
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          </main>
          
          <footer className="border-t border-gray-800/50 mt-auto">
            <div className="max-w-6xl mx-auto px-4 sm:px-6 py-4 flex items-center justify-between text-sm text-gray-500">
              <span>FIUP Tool v3.3</span>
              <span className="hidden sm:inline">å¢é‡è¡¥ä¸ Â· å¤šç›®æ ‡å®šä½ Â· å®½æ¾åŒ¹é…</span>
              <a href="https://github.com/Thankyou-Cheems" target="_blank" className="hover:text-gray-300">çŒ¹Cheems</a>
            </div>
          </footer>

          {toast && <Toast message={toast.message} type={toast.type} onClose={() => setToast(null)} />}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<FIUPApp />);
  </script>
</body>
</html>
