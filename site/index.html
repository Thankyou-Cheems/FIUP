<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FIUP Tool v3.5 - Â¢ûÂº∫Áâà</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- Prism.js for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markdown.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            gray: {
              950: '#0a0a0f',
              900: '#111118',
              800: '#1a1a24',
              700: '#2a2a38',
              600: '#3a3a4a',
              500: '#5a5a6a',
              400: '#8a8a9a',
              300: '#b0b0c0',
            }
          }
        }
      }
    }
  </script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    pre, code, .font-mono { font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', Consolas, monospace; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #3a3a4a; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #5a5a6a; }
    textarea.edit-area { tab-size: 2; }
    .drag-over { background: rgba(139, 92, 246, 0.2) !important; border-color: rgba(139, 92, 246, 0.5) !important; }
    .dragging { opacity: 0.5; }
    .drag-handle { cursor: grab; }
    .drag-handle:active { cursor: grabbing; }
    .dep-line { stroke: #6366f1; stroke-width: 2; fill: none; }
    .dep-arrow { fill: #6366f1; }
    /* Prism overrides for dark theme */
    pre[class*="language-"], code[class*="language-"] {
      background: transparent !important;
      text-shadow: none !important;
      font-size: 0.875rem !important;
    }
    .token.comment { color: #6a737d !important; }
    .token.keyword { color: #ff79c6 !important; }
    .token.string { color: #a5d6ff !important; }
    .token.function { color: #d2a8ff !important; }
    .token.number { color: #79c0ff !important; }
    .token.operator { color: #ff7b72 !important; }
    .token.class-name { color: #ffa657 !important; }
    /* Inline diff highlights */
    .diff-char-add { background: rgba(46, 160, 67, 0.4); border-radius: 2px; }
    .diff-char-del { background: rgba(248, 81, 73, 0.4); border-radius: 2px; text-decoration: line-through; }
    .diff-word-add { background: rgba(46, 160, 67, 0.3); padding: 1px 2px; border-radius: 3px; }
    .diff-word-del { background: rgba(248, 81, 73, 0.3); padding: 1px 2px; border-radius: 3px; text-decoration: line-through; }
    /* Shortcut hints */
    .kbd { 
      display: inline-block;
      padding: 2px 6px;
      font-size: 11px;
      font-family: monospace;
      background: #2a2a38;
      border: 1px solid #3a3a4a;
      border-radius: 4px;
      box-shadow: 0 1px 0 #3a3a4a;
    }
    /* Template dropdown */
    .template-dropdown {
      animation: slideDown 0.15s ease-out;
    }
    @keyframes slideDown {
      from { opacity: 0; transform: translateY(-8px); }
      to { opacity: 1; transform: translateY(0); }
    }
    /* Suggestion highlight */
    .suggestion-match { color: #ffa657; font-weight: 600; }
    /* Active patch highlight */
    .patch-active { box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.5); }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useCallback, useMemo, useEffect, useRef } = React;

    // ============================================================================
    // Icons
    // ============================================================================
    const Icons = {
      Upload: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>,
      FileText: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><line x1="10" y1="9" x2="8" y2="9"/></svg>,
      FilePlus: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="12" y1="18" x2="12" y2="12"/><line x1="9" y1="15" x2="15" y2="15"/></svg>,
      Folder: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>,
      Archive: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="21 8 21 21 3 21 3 8"/><rect x="1" y="3" width="22" height="5"/><line x1="10" y1="12" x2="14" y2="12"/></svg>,
      Play: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
      Eye: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>,
      EyeOff: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>,
      CheckCircle: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>,
      XCircle: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>,
      AlertTriangle: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>,
      Copy: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>,
      Trash2: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>,
      ChevronDown: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 12 15 18 9"/></svg>,
      ChevronRight: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6"/></svg>,
      Code: (props) => <svg xmlns="http://www.w3.org/2000/svg" width={props?.size || 20} height={props?.size || 20} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>,
      RefreshCw: () => <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>,
      Github: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>,
      Download: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>,
      Edit: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>,
      Save: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>,
      X: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>,
      Info: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>,
      Zap: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>,
      Layers: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>,
      Target: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>,
      MapPin: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>,
      GripVertical: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="9" cy="12" r="1"/><circle cx="9" cy="5" r="1"/><circle cx="9" cy="19" r="1"/><circle cx="15" cy="12" r="1"/><circle cx="15" cy="5" r="1"/><circle cx="15" cy="19" r="1"/></svg>,
      Undo: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>,
      Redo: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg>,
      GitBranch: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="6" y1="3" x2="6" y2="15"/><circle cx="18" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><path d="M18 9a9 9 0 0 1-9 9"/></svg>,
      Network: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="16" y="16" width="6" height="6" rx="1"/><rect x="2" y="16" width="6" height="6" rx="1"/><rect x="9" y="2" width="6" height="6" rx="1"/><path d="M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3"/><line x1="12" y1="12" x2="12" y2="8"/></svg>,
      ArrowUp: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg>,
      ArrowDown: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><polyline points="19 12 12 19 5 12"/></svg>,
      Template: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/></svg>,
      Keyboard: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="4" width="20" height="16" rx="2" ry="2"/><path d="M6 8h.001"/><path d="M10 8h.001"/><path d="M14 8h.001"/><path d="M18 8h.001"/><path d="M8 12h.001"/><path d="M12 12h.001"/><path d="M16 12h.001"/><path d="M7 16h10"/></svg>,
      Wand: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M15 9h0"/><path d="M17.8 6.2 19 5"/><path d="m3 21 9-9"/><path d="M12.2 6.2 11 5"/></svg>,
      Search: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>,
      Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
    };

    // ============================================================================
    // Syntax Highlighting Utilities
    // ============================================================================
    const getLanguageFromFileName = (fileName) => {
      if (!fileName) return 'text';
      const ext = fileName.split('.').pop()?.toLowerCase();
      const langMap = {
        'js': 'javascript', 'jsx': 'jsx', 'ts': 'typescript', 'tsx': 'tsx',
        'py': 'python', 'rb': 'ruby', 'java': 'java', 'kt': 'kotlin',
        'c': 'c', 'cpp': 'cpp', 'cc': 'cpp', 'h': 'c', 'hpp': 'cpp',
        'cs': 'csharp', 'go': 'go', 'rs': 'rust', 'swift': 'swift',
        'css': 'css', 'scss': 'scss', 'less': 'less', 'html': 'html',
        'xml': 'xml', 'json': 'json', 'yaml': 'yaml', 'yml': 'yaml',
        'md': 'markdown', 'sql': 'sql', 'sh': 'bash', 'bash': 'bash',
        'zsh': 'bash', 'fish': 'bash', 'ps1': 'powershell',
        'php': 'php', 'vue': 'vue', 'svelte': 'svelte',
      };
      return langMap[ext] || 'text';
    };

    const highlightCode = (code, language) => {
      if (!code) return '';
      try {
        if (Prism.languages[language]) {
          return Prism.highlight(code, Prism.languages[language], language);
        }
      } catch (e) {}
      return code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    };

    // Syntax highlighted code block component
    const SyntaxHighlightedCode = ({ code, language, className = '' }) => {
      const highlighted = useMemo(() => highlightCode(code, language), [code, language]);
      return (
        <pre className={`bg-black/30 rounded-lg p-3 text-sm overflow-x-auto font-mono whitespace-pre ${className}`}>
          <code dangerouslySetInnerHTML={{ __html: highlighted }} />
        </pre>
      );
    };

    // ============================================================================
    // Inline Diff Algorithm (Character/Word Level)
    // ============================================================================
    const computeInlineDiff = (oldStr, newStr) => {
      // Simple word-level diff
      const oldWords = oldStr.split(/(\s+)/);
      const newWords = newStr.split(/(\s+)/);
      
      const result = { oldParts: [], newParts: [] };
      
      // LCS-based diff for words
      const lcs = [];
      for (let i = 0; i <= oldWords.length; i++) {
        lcs[i] = [];
        for (let j = 0; j <= newWords.length; j++) {
          if (i === 0 || j === 0) lcs[i][j] = 0;
          else if (oldWords[i-1] === newWords[j-1]) lcs[i][j] = lcs[i-1][j-1] + 1;
          else lcs[i][j] = Math.max(lcs[i-1][j], lcs[i][j-1]);
        }
      }
      
      // Backtrack
      let i = oldWords.length, j = newWords.length;
      const oldResult = [], newResult = [];
      
      while (i > 0 || j > 0) {
        if (i > 0 && j > 0 && oldWords[i-1] === newWords[j-1]) {
          oldResult.unshift({ text: oldWords[i-1], type: 'same' });
          newResult.unshift({ text: newWords[j-1], type: 'same' });
          i--; j--;
        } else if (j > 0 && (i === 0 || lcs[i][j-1] >= lcs[i-1][j])) {
          newResult.unshift({ text: newWords[j-1], type: 'add' });
          j--;
        } else if (i > 0) {
          oldResult.unshift({ text: oldWords[i-1], type: 'del' });
          i--;
        }
      }
      
      return { oldParts: oldResult, newParts: newResult };
    };

    // Render inline diff HTML
    const renderInlineDiff = (parts, type) => {
      return parts.map((part, idx) => {
        if (part.type === 'same') return part.text;
        const cls = part.type === 'add' ? 'diff-word-add' : 'diff-word-del';
        return `<span class="${cls}">${part.text.replace(/&/g, '&amp;').replace(/</g, '&lt;')}</span>`;
      }).join('');
    };

    // ============================================================================
    // Smart Anchor Suggestion (Similarity Algorithm)
    // ============================================================================
    const levenshteinDistance = (a, b) => {
      const matrix = [];
      for (let i = 0; i <= b.length; i++) matrix[i] = [i];
      for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
      for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
          if (b[i-1] === a[j-1]) matrix[i][j] = matrix[i-1][j-1];
          else matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, matrix[i][j-1] + 1, matrix[i-1][j] + 1);
        }
      }
      return matrix[b.length][a.length];
    };

    const similarity = (a, b) => {
      if (!a || !b) return 0;
      const maxLen = Math.max(a.length, b.length);
      if (maxLen === 0) return 1;
      return (maxLen - levenshteinDistance(a, b)) / maxLen;
    };

    const findSmartSuggestions = (content, anchor, maxResults = 5) => {
      if (!content || !anchor) return [];
      
      const anchorLines = anchor.split('\n');
      const anchorFirstLine = anchorLines[0]?.trim() || '';
      const anchorNormalized = anchor.replace(/\s+/g, ' ').trim();
      const contentLines = content.split('\n');
      
      const candidates = [];
      
      // Sliding window approach
      for (let i = 0; i < contentLines.length; i++) {
        const windowSize = anchorLines.length;
        const windowEnd = Math.min(i + windowSize, contentLines.length);
        const windowContent = contentLines.slice(i, windowEnd).join('\n');
        const windowNormalized = windowContent.replace(/\s+/g, ' ').trim();
        
        // Calculate similarity score
        const sim = similarity(anchorNormalized, windowNormalized);
        
        // Also check first line similarity
        const firstLineSim = similarity(anchorFirstLine, contentLines[i]?.trim() || '');
        
        // Combined score
        const score = sim * 0.7 + firstLineSim * 0.3;
        
        if (score > 0.3) {
          candidates.push({
            line: i + 1,
            preview: windowContent,
            score,
            similarity: Math.round(sim * 100),
            matchedParts: findMatchedParts(anchorFirstLine, contentLines[i] || '')
          });
        }
      }
      
      // Sort by score and dedupe
      return candidates
        .sort((a, b) => b.score - a.score)
        .filter((c, idx, arr) => idx === 0 || Math.abs(c.line - arr[idx-1].line) > anchorLines.length)
        .slice(0, maxResults);
    };

    const findMatchedParts = (anchor, content) => {
      // Find common substrings for highlighting
      const words = anchor.toLowerCase().split(/\s+/).filter(w => w.length > 2);
      const matches = [];
      words.forEach(word => {
        const idx = content.toLowerCase().indexOf(word);
        if (idx !== -1) matches.push({ start: idx, end: idx + word.length });
      });
      return matches;
    };

    // ============================================================================
    // Patch Templates
    // ============================================================================
    const PATCH_TEMPLATES = [
      {
        id: 'add-import-python',
        name: 'Ê∑ªÂä† Python Import',
        icon: 'üêç',
        operation: 'INSERT_BEFORE',
        description: 'Âú®Êñá‰ª∂ÂºÄÂ§¥Ê∑ªÂä† import ËØ≠Âè•',
        template: {
          anchor: 'import ',
          content: 'import new_module\n'
        }
      },
      {
        id: 'add-import-js',
        name: 'Ê∑ªÂä† JS/TS Import',
        icon: 'üì¶',
        operation: 'INSERT_BEFORE',
        description: 'Âú®Êñá‰ª∂ÂºÄÂ§¥Ê∑ªÂä† import ËØ≠Âè•',
        template: {
          anchor: "import ",
          content: "import { something } from 'module';\n"
        }
      },
      {
        id: 'add-method',
        name: 'Ê∑ªÂä†Á±ªÊñπÊ≥ï',
        icon: 'üîß',
        operation: 'INSERT_AFTER',
        description: 'Âú®Áé∞ÊúâÊñπÊ≥ïÂêéÊ∑ªÂä†Êñ∞ÊñπÊ≥ï',
        template: {
          anchor: '    def existing_method(self):\n        pass',
          content: '\n    def new_method(self):\n        """New method description."""\n        pass'
        }
      },
      {
        id: 'add-function',
        name: 'Ê∑ªÂä†ÂáΩÊï∞',
        icon: '‚ö°',
        operation: 'INSERT_AFTER',
        description: 'Âú®Áé∞ÊúâÂáΩÊï∞ÂêéÊ∑ªÂä†Êñ∞ÂáΩÊï∞',
        template: {
          anchor: 'def existing_function():\n    pass',
          content: '\n\ndef new_function():\n    """New function description."""\n    pass'
        }
      },
      {
        id: 'replace-function',
        name: 'ÊõøÊç¢ÂáΩÊï∞ÂÆûÁé∞',
        icon: 'üîÑ',
        operation: 'REPLACE',
        description: 'ÊõøÊç¢Êï¥‰∏™ÂáΩÊï∞ÂÆûÁé∞',
        template: {
          anchor: 'def old_function():\n    # old implementation\n    pass',
          content: 'def old_function():\n    # new implementation\n    return True'
        }
      },
      {
        id: 'add-decorator',
        name: 'Ê∑ªÂä†Ë£ÖÈ•∞Âô®',
        icon: 'üéÄ',
        operation: 'INSERT_BEFORE',
        description: 'Âú®ÂáΩÊï∞/ÊñπÊ≥ïÂâçÊ∑ªÂä†Ë£ÖÈ•∞Âô®',
        template: {
          anchor: 'def some_function',
          content: '@decorator\n'
        }
      },
      {
        id: 'add-comment',
        name: 'Ê∑ªÂä†Ê≥®ÈáäÂùó',
        icon: 'üí¨',
        operation: 'INSERT_BEFORE',
        description: 'Âú®‰ª£Á†ÅÂâçÊ∑ªÂä†Ê≥®Èáä',
        template: {
          anchor: 'code_line',
          content: '# TODO: Description\n# Additional notes\n'
        }
      },
      {
        id: 'delete-function',
        name: 'Âà†Èô§ÂáΩÊï∞',
        icon: 'üóëÔ∏è',
        operation: 'DELETE',
        description: 'Âà†Èô§Êï¥‰∏™ÂáΩÊï∞',
        template: {
          anchor: 'def deprecated_function():\n    pass',
          content: ''
        }
      },
      {
        id: 'create-file',
        name: 'ÂàõÂª∫Êñ∞Êñá‰ª∂',
        icon: 'üìÑ',
        operation: 'CREATE',
        description: 'ÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑ‰ª£Á†ÅÊñá‰ª∂',
        template: {
          anchor: '',
          content: '"""Module description."""\n\n\nclass NewClass:\n    """Class description."""\n    \n    def __init__(self):\n        pass'
        }
      },
      {
        id: 'add-config',
        name: 'Ê∑ªÂä†ÈÖçÁΩÆÈ°π',
        icon: '‚öôÔ∏è',
        operation: 'INSERT_AFTER',
        description: 'Âú®ÈÖçÁΩÆÊñá‰ª∂‰∏≠Ê∑ªÂä†Êñ∞ÈÖçÁΩÆ',
        template: {
          anchor: '# Configuration',
          content: '\nNEW_CONFIG = "value"'
        }
      }
    ];

    // ============================================================================
    // FIUP Parser
    // ============================================================================
    const parseFIUP = (text) => {
      let content = text;
      const codeBlockPattern = /```(?:fiup)?\s*\n([\s\S]*?)```/g;
      let extracted = '';
      let match;
      while ((match = codeBlockPattern.exec(text)) !== null) {
        extracted += match[1] + '\n';
      }
      if (extracted) content = extracted;
      
      const patches = [];
      const blockPattern = /<<<FIUP>>>([\s\S]*?)<<<END>>>/g;
      
      while ((match = blockPattern.exec(content)) !== null) {
        const block = match[0];
        const inner = match[1];
        
        const fileMatch = inner.match(/\[FILE\]:\s*(.+?)(?:\n|$)/);
        const file = fileMatch ? fileMatch[1].trim() : '';
        
        const opMatch = inner.match(/\[OP\]:\s*(REPLACE|INSERT_AFTER|INSERT_BEFORE|DELETE|CREATE)(?:\n|$)/i);
        const operation = opMatch ? opMatch[1].toUpperCase() : '';
        
        let anchor = '';
        let contentText = '';
        
        const anchorMatch = inner.match(/\[ANCHOR\]\s*\n([\s\S]*?)(?=\[CONTENT\]|$)/);
        if (anchorMatch) anchor = anchorMatch[1].replace(/\n$/, '');
        
        const contentMatch = inner.match(/\[CONTENT\]\s*\n([\s\S]*?)$/);
        if (contentMatch) contentText = contentMatch[1].replace(/\n$/, '');
        
        patches.push({
          id: crypto.randomUUID(),
          file,
          operation,
          anchor,
          content: contentText,
          raw: block,
          selectedMatchIndex: null
        });
      }
      
      return patches;
    };

    const generateRaw = (patch) => {
      if (patch.operation === 'CREATE') {
        return `<<<FIUP>>>\n[FILE]: ${patch.file}\n[OP]: ${patch.operation}\n[CONTENT]\n${patch.content}\n<<<END>>>`;
      }
      let raw = `<<<FIUP>>>\n[FILE]: ${patch.file}\n[OP]: ${patch.operation}\n[ANCHOR]\n${patch.anchor}`;
      if (patch.operation !== 'DELETE') {
        raw += `\n[CONTENT]\n${patch.content}`;
      }
      return raw + `\n<<<END>>>`;
    };

    // ============================================================================
    // Matching Functions
    // ============================================================================
    const normalizeWhitespace = (text) => {
      return text.split('\n').map(line => line.trimEnd()).join('\n').replace(/[ \t]+/g, ' ');
    };

    const findAllMatches = (content, anchor, fuzzyMatch = false) => {
      const normalizedContent = content.replace(/\r\n/g, '\n');
      const normalizedAnchor = anchor.replace(/\r\n/g, '\n');
      
      let searchContent = normalizedContent;
      let searchAnchor = normalizedAnchor;
      
      if (fuzzyMatch) {
        searchContent = normalizeWhitespace(normalizedContent);
        searchAnchor = normalizeWhitespace(normalizedAnchor);
      }
      
      const matches = [];
      let pos = 0;
      
      while ((pos = searchContent.indexOf(searchAnchor, pos)) !== -1) {
        const beforeText = normalizedContent.substring(0, pos);
        const line = beforeText.split('\n').length;
        const contentLines = normalizedContent.split('\n');
        const startLine = Math.max(0, line - 2);
        const endLine = Math.min(contentLines.length, line + normalizedAnchor.split('\n').length + 1);
        const preview = contentLines.slice(startLine, endLine).join('\n');
        
        matches.push({ position: pos, line, preview, startLine: startLine + 1, endLine });
        pos += 1;
      }
      
      return matches;
    };

    const findSimilarContent = (content, anchor, maxResults = 5) => {
      const anchorLines = anchor.split('\n').filter(l => l.trim());
      if (anchorLines.length === 0) return [];
      
      const firstLine = anchorLines[0].trim();
      const contentLines = content.split('\n');
      const matches = [];
      
      for (let i = 0; i < contentLines.length; i++) {
        if (contentLines[i].trim() === firstLine) {
          matches.push({ line: i + 1, preview: contentLines.slice(i, i + anchorLines.length).join('\n') });
        }
      }
      
      return matches.slice(0, maxResults);
    };

    const simulateApply = (content, patch, fuzzyMatch = false, matchIndex = null) => {
      if (patch.operation === 'CREATE') {
        return { success: true, message: 'Êñ∞Âª∫Êñá‰ª∂', result: patch.content, isCreate: true };
      }
      
      const normalizedContent = content.replace(/\r\n/g, '\n');
      const normalizedAnchor = patch.anchor.replace(/\r\n/g, '\n');
      
      const allMatches = findAllMatches(normalizedContent, normalizedAnchor, fuzzyMatch);
      
      if (allMatches.length === 0) {
        const similar = findSimilarContent(normalizedContent, normalizedAnchor);
        const smartSuggestions = findSmartSuggestions(normalizedContent, normalizedAnchor);
        return { 
          success: false, 
          message: 'ÈîöÁÇπÊú™ÊâæÂà∞', 
          result: content,
          similar: similar.length > 0 ? similar : null,
          smartSuggestions: smartSuggestions.length > 0 ? smartSuggestions : null,
          debugInfo: {
            anchorLength: normalizedAnchor.length,
            hasTab: normalizedAnchor.includes('\t'),
            hasTrailingSpace: /[ \t]$/.test(normalizedAnchor),
            lineCount: normalizedAnchor.split('\n').length
          }
        };
      }
      
      if (allMatches.length > 1) {
        if (matchIndex === null || matchIndex < 0 || matchIndex >= allMatches.length) {
          return { 
            success: false, 
            message: `ÈîöÁÇπÂåπÈÖçÂà∞ ${allMatches.length} Â§Ñ`, 
            result: content,
            multipleMatches: allMatches,
            matchCount: allMatches.length
          };
        }
      }
      
      const targetMatch = matchIndex !== null ? allMatches[matchIndex] : allMatches[0];
      const pos = targetMatch.position;
      
      const before = normalizedContent.slice(0, pos);
      const after = normalizedContent.slice(pos + normalizedAnchor.length);
      let result;
      
      switch (patch.operation) {
        case 'REPLACE':
          result = before + patch.content + after;
          break;
        case 'INSERT_AFTER':
          const sep1 = normalizedAnchor.endsWith('\n') ? '' : '\n';
          result = before + normalizedAnchor + sep1 + patch.content + after;
          break;
        case 'INSERT_BEFORE':
          const sep2 = patch.content.endsWith('\n') ? '' : '\n';
          result = before + patch.content + sep2 + normalizedAnchor + after;
          break;
        case 'DELETE':
          result = before + after;
          break;
        default:
          result = content;
      }
      
      const line = before.split('\n').length;
      return { 
        success: true, 
        message: `${fuzzyMatch ? 'ÂÆΩÊùæÂåπÈÖç' : 'Á≤æÁ°ÆÂåπÈÖç'} @ Ë°å ${line}${matchIndex !== null ? ` (Á¨¨${matchIndex + 1}Â§Ñ)` : ''}`, 
        result, 
        line,
        fuzzyMatched: fuzzyMatch,
        usedMatchIndex: matchIndex
      };
    };

    const validatePatch = (patch) => {
      const errors = [];
      const warnings = [];
      
      if (!patch.file) errors.push('Êñá‰ª∂Ë∑ØÂæÑ‰∏∫Á©∫');
      
      if (patch.operation === 'CREATE') {
        if (!patch.content?.trim()) errors.push('CREATE Êìç‰Ωú‰ΩÜÂÜÖÂÆπ‰∏∫Á©∫');
      } else {
        if (!patch.anchor?.trim()) errors.push('ÈîöÁÇπÂÜÖÂÆπ‰∏∫Á©∫');
        const anchorLines = patch.anchor?.trim().split('\n').length || 0;
        if (anchorLines < 2) warnings.push(`ÈîöÁÇπ‰ªÖ ${anchorLines} Ë°å`);
        if (patch.operation !== 'DELETE' && !patch.content?.trim()) {
          errors.push('Èùû DELETE/CREATE Êìç‰Ωú‰ΩÜÂÜÖÂÆπ‰∏∫Á©∫');
        }
        if (patch.anchor?.includes('\t')) warnings.push('ÈîöÁÇπÂåÖÂê´Tab');
        if (/[ \t]$/.test(patch.anchor)) warnings.push('ÈîöÁÇπÂåÖÂê´Ë°åÂ∞æÁ©∫ÁôΩ');
      }
      
      return { valid: errors.length === 0, errors, warnings };
    };

    const opColors = {
      REPLACE: { bg: 'bg-blue-500/10', text: 'text-blue-400', border: 'border-blue-500/30' },
      INSERT_AFTER: { bg: 'bg-green-500/10', text: 'text-green-400', border: 'border-green-500/30' },
      INSERT_BEFORE: { bg: 'bg-emerald-500/10', text: 'text-emerald-400', border: 'border-emerald-500/30' },
      DELETE: { bg: 'bg-red-500/10', text: 'text-red-400', border: 'border-red-500/30' },
      CREATE: { bg: 'bg-purple-500/10', text: 'text-purple-400', border: 'border-purple-500/30' }
    };

    const operations = ['REPLACE', 'INSERT_AFTER', 'INSERT_BEFORE', 'DELETE', 'CREATE'];

    // ============================================================================
    // History Hook (Undo/Redo)
    // ============================================================================
    const useHistory = (initialState, maxHistory = 50) => {
      const [history, setHistory] = useState([initialState]);
      const [currentIndex, setCurrentIndex] = useState(0);
      
      const current = history[currentIndex];
      
      const push = useCallback((newState) => {
        setHistory(prev => {
          const newHistory = prev.slice(0, currentIndex + 1);
          newHistory.push(newState);
          if (newHistory.length > maxHistory) newHistory.shift();
          return newHistory;
        });
        setCurrentIndex(prev => Math.min(prev + 1, maxHistory - 1));
      }, [currentIndex, maxHistory]);
      
      const undo = useCallback(() => {
        if (currentIndex > 0) setCurrentIndex(prev => prev - 1);
      }, [currentIndex]);
      
      const redo = useCallback(() => {
        if (currentIndex < history.length - 1) setCurrentIndex(prev => prev + 1);
      }, [currentIndex, history.length]);
      
      const canUndo = currentIndex > 0;
      const canRedo = currentIndex < history.length - 1;
      
      return { current, push, undo, redo, canUndo, canRedo };
    };

    // ============================================================================
    // Dependency Analysis
    // ============================================================================
    const analyzeDependencies = (patches, files, fuzzyMatch) => {
      const deps = [];
      
      const fileGroups = {};
      patches.forEach((patch, index) => {
        const file = patch.file;
        if (!fileGroups[file]) fileGroups[file] = [];
        fileGroups[file].push({ patch, index });
      });
      
      Object.values(fileGroups).forEach(group => {
        for (let i = 1; i < group.length; i++) {
          const prev = group[i - 1];
          const curr = group[i];
          
          deps.push({ from: prev.index, to: curr.index, type: 'order' });
          
          if (curr.patch.anchor && prev.patch.content) {
            if (prev.patch.content.includes(curr.patch.anchor.split('\n')[0]?.trim())) {
              deps.push({ from: prev.index, to: curr.index, type: 'content' });
            }
          }
        }
      });
      
      return deps;
    };

    // ============================================================================
    // Keyboard Shortcuts Hook
    // ============================================================================
    const useKeyboardShortcuts = (handlers) => {
      useEffect(() => {
        const handleKeyDown = (e) => {
          const isMod = e.ctrlKey || e.metaKey;
          
          // Ctrl+Z / Cmd+Z - Undo
          if (isMod && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            handlers.undo?.();
          }
          // Ctrl+Shift+Z / Cmd+Shift+Z - Redo
          if (isMod && e.key === 'z' && e.shiftKey) {
            e.preventDefault();
            handlers.redo?.();
          }
          // Ctrl+Y / Cmd+Y - Redo (alternative)
          if (isMod && e.key === 'y') {
            e.preventDefault();
            handlers.redo?.();
          }
          // Ctrl+S / Cmd+S - Save/Apply
          if (isMod && e.key === 's') {
            e.preventDefault();
            handlers.save?.();
          }
          // Ctrl+Enter - Parse
          if (isMod && e.key === 'Enter') {
            e.preventDefault();
            handlers.parse?.();
          }
          // Arrow Up/Down for patch navigation (when not in input)
          if (e.key === 'ArrowUp' && e.altKey) {
            e.preventDefault();
            handlers.prevPatch?.();
          }
          if (e.key === 'ArrowDown' && e.altKey) {
            e.preventDefault();
            handlers.nextPatch?.();
          }
          // Escape - close/cancel
          if (e.key === 'Escape') {
            handlers.escape?.();
          }
          // Ctrl+N - New patch from template
          if (isMod && e.key === 'n') {
            e.preventDefault();
            handlers.newPatch?.();
          }
          // ? - Show shortcuts help
          if (e.key === '?' && e.shiftKey) {
            e.preventDefault();
            handlers.showHelp?.();
          }
        };
        
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [handlers]);
    };

    // ============================================================================
    // Shortcuts Help Modal
    // ============================================================================
    const ShortcutsModal = ({ onClose }) => (
      <div className="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4" onClick={onClose}>
        <div className="bg-gray-800 rounded-2xl border border-gray-700 max-w-lg w-full p-6 shadow-2xl" onClick={e => e.stopPropagation()}>
          <div className="flex items-center justify-between mb-6">
            <h2 className="text-xl font-semibold flex items-center gap-2">
              <Icons.Keyboard />
              ÈîÆÁõòÂø´Êç∑ÈîÆ
            </h2>
            <button onClick={onClose} className="p-2 hover:bg-gray-700 rounded-lg text-gray-400">
              <Icons.X />
            </button>
          </div>
          
          <div className="space-y-4">
            <div className="grid grid-cols-2 gap-3">
              {[
                { keys: ['Ctrl', 'Z'], desc: 'Êí§ÈîÄ' },
                { keys: ['Ctrl', 'Shift', 'Z'], desc: 'ÈáçÂÅö' },
                { keys: ['Ctrl', 'S'], desc: '‰øùÂ≠òÁºñËæë' },
                { keys: ['Ctrl', 'Enter'], desc: 'Ëß£ÊûêË°•‰∏Å' },
                { keys: ['Alt', '‚Üë'], desc: '‰∏ä‰∏Ä‰∏™Ë°•‰∏Å' },
                { keys: ['Alt', '‚Üì'], desc: '‰∏ã‰∏Ä‰∏™Ë°•‰∏Å' },
                { keys: ['Ctrl', 'N'], desc: '‰ªéÊ®°ÊùøÊñ∞Âª∫' },
                { keys: ['Esc'], desc: 'ÂèñÊ∂à/ÂÖ≥Èó≠' },
                { keys: ['?'], desc: 'ÊòæÁ§∫Â∏ÆÂä©' },
              ].map(({ keys, desc }) => (
                <div key={desc} className="flex items-center justify-between p-2 rounded-lg bg-gray-900/50">
                  <span className="text-gray-400 text-sm">{desc}</span>
                  <div className="flex gap-1">
                    {keys.map(k => <span key={k} className="kbd">{k}</span>)}
                  </div>
                </div>
              ))}
            </div>
          </div>
          
          <div className="mt-6 pt-4 border-t border-gray-700 text-center text-sm text-gray-500">
            Êåâ <span className="kbd">Esc</span> ÂÖ≥Èó≠
          </div>
        </div>
      </div>
    );

    // ============================================================================
    // Template Selector Modal
    // ============================================================================
    const TemplateSelector = ({ onSelect, onClose }) => {
      const [search, setSearch] = useState('');
      
      const filteredTemplates = useMemo(() => {
        if (!search) return PATCH_TEMPLATES;
        const q = search.toLowerCase();
        return PATCH_TEMPLATES.filter(t => 
          t.name.toLowerCase().includes(q) || 
          t.description.toLowerCase().includes(q) ||
          t.operation.toLowerCase().includes(q)
        );
      }, [search]);
      
      return (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4" onClick={onClose}>
          <div className="template-dropdown bg-gray-800 rounded-2xl border border-gray-700 max-w-2xl w-full p-6 shadow-2xl max-h-[80vh] overflow-hidden flex flex-col" onClick={e => e.stopPropagation()}>
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-semibold flex items-center gap-2">
                <Icons.Template />
                Ë°•‰∏ÅÊ®°Êùø
              </h2>
              <button onClick={onClose} className="p-2 hover:bg-gray-700 rounded-lg text-gray-400">
                <Icons.X />
              </button>
            </div>
            
            <div className="relative mb-4">
              <Icons.Search />
              <input
                type="text"
                value={search}
                onChange={e => setSearch(e.target.value)}
                placeholder="ÊêúÁ¥¢Ê®°Êùø..."
                className="w-full bg-gray-900/50 border border-gray-700 rounded-lg pl-10 pr-4 py-2.5 text-sm focus:border-violet-500 focus:outline-none"
                autoFocus
              />
              <div className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-500">
                <Icons.Search />
              </div>
            </div>
            
            <div className="flex-1 overflow-y-auto space-y-2">
              {filteredTemplates.map(template => {
                const color = opColors[template.operation];
                return (
                  <button
                    key={template.id}
                    onClick={() => { onSelect(template); onClose(); }}
                    className="w-full p-4 rounded-xl border border-gray-700 hover:border-violet-500/50 hover:bg-gray-700/30 transition-all text-left group"
                  >
                    <div className="flex items-center gap-3 mb-2">
                      <span className="text-2xl">{template.icon}</span>
                      <div className="flex-1">
                        <div className="font-medium text-white group-hover:text-violet-300">{template.name}</div>
                        <div className="text-xs text-gray-500">{template.description}</div>
                      </div>
                      <span className={`px-2 py-0.5 rounded text-xs font-mono ${color?.text} ${color?.bg} border ${color?.border}`}>
                        {template.operation}
                      </span>
                    </div>
                  </button>
                );
              })}
              
              {filteredTemplates.length === 0 && (
                <div className="text-center py-8 text-gray-500">
                  Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÊ®°Êùø
                </div>
              )}
            </div>
            
            <div className="mt-4 pt-4 border-t border-gray-700 text-center text-xs text-gray-500">
              ÈÄâÊã©Ê®°ÊùøÂêéÂèØÂú®ÁºñËæëÂô®‰∏≠‰øÆÊîπ ¬∑ Êåâ <span className="kbd">Esc</span> ÂÖ≥Èó≠
            </div>
          </div>
        </div>
      );
    };

    // ============================================================================
    // Smart Suggestion Panel
    // ============================================================================
    const SmartSuggestionPanel = ({ suggestions, onApply, fileName }) => {
      const lang = getLanguageFromFileName(fileName);
      
      return (
        <div className="mt-3 p-4 bg-gradient-to-br from-violet-500/10 to-fuchsia-500/10 rounded-xl border border-violet-500/30">
          <div className="flex items-center gap-2 text-sm font-medium text-violet-300 mb-3">
            <Icons.Wand />
            Êô∫ËÉΩÂª∫ËÆÆ - Áõ∏‰ºº‰ª£Á†ÅÊÆµ
          </div>
          <div className="space-y-3 max-h-64 overflow-y-auto">
            {suggestions.map((sug, idx) => (
              <div 
                key={idx}
                className="p-3 bg-black/30 rounded-lg border border-gray-700 hover:border-violet-500/50 cursor-pointer transition-all group"
                onClick={() => onApply(sug)}
              >
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <Icons.MapPin />
                    <span className="text-sm font-medium text-violet-300">Ë°å {sug.line}</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className={`text-xs px-2 py-0.5 rounded ${
                      sug.similarity >= 80 ? 'bg-green-500/20 text-green-400' :
                      sug.similarity >= 60 ? 'bg-yellow-500/20 text-yellow-400' :
                      'bg-orange-500/20 text-orange-400'
                    }`}>
                      {sug.similarity}% Áõ∏‰ºº
                    </span>
                    <span className="text-xs text-gray-500 opacity-0 group-hover:opacity-100 transition-opacity">
                      ÁÇπÂáªÂ∫îÁî®
                    </span>
                  </div>
                </div>
                <SyntaxHighlightedCode 
                  code={sug.preview} 
                  language={lang}
                  className="text-xs"
                />
              </div>
            ))}
          </div>
          <div className="mt-3 text-xs text-gray-500 flex items-center gap-1">
            <Icons.Info />
            ÁÇπÂáªÂª∫ËÆÆÂèØËá™Âä®Êõ¥Êñ∞ÈîöÁÇπ
          </div>
        </div>
      );
    };

    // ============================================================================
    // DiffView Component with Inline Diff
    // ============================================================================
    const DiffView = ({ original, modified, fileName, showInlineDiff = true }) => {
      const lang = getLanguageFromFileName(fileName);
      
      const diff = useMemo(() => {
        if (!original && !modified) return [];
        const oldLines = (original || '').split('\n');
        const newLines = (modified || '').split('\n');
        const result = [];
        
        let i = 0, j = 0;
        while (i < oldLines.length || j < newLines.length) {
          if (i < oldLines.length && j < newLines.length && oldLines[i] === newLines[j]) {
            result.push({ type: 'same', content: oldLines[i], lineOld: i + 1, lineNew: j + 1 });
            i++; j++;
          } else if (j < newLines.length && (i >= oldLines.length || !oldLines.includes(newLines[j]))) {
            // Check for inline diff with previous del line
            const prevDel = result.length > 0 && result[result.length - 1].type === 'del' ? result[result.length - 1] : null;
            if (showInlineDiff && prevDel) {
              const inlineDiff = computeInlineDiff(prevDel.content, newLines[j]);
              prevDel.inlineDiff = inlineDiff.oldParts;
              result.push({ type: 'add', content: newLines[j], lineNew: j + 1, inlineDiff: inlineDiff.newParts });
            } else {
              result.push({ type: 'add', content: newLines[j], lineNew: j + 1 });
            }
            j++;
          } else if (i < oldLines.length) {
            result.push({ type: 'del', content: oldLines[i], lineOld: i + 1 });
            i++;
          }
        }
        return result;
      }, [original, modified, showInlineDiff]);
      
      const renderLine = (line) => {
        if (line.inlineDiff) {
          return <span dangerouslySetInnerHTML={{ __html: renderInlineDiff(line.inlineDiff) }} />;
        }
        // Apply syntax highlighting for unchanged lines
        if (line.type === 'same') {
          return <span dangerouslySetInnerHTML={{ __html: highlightCode(line.content, lang) }} />;
        }
        return line.content;
      };
      
      return (
        <div className="bg-gray-900/50 rounded-xl overflow-hidden border border-gray-700/50">
          <div className="flex items-center justify-between px-4 py-2 border-b border-gray-700/50 bg-gray-800/30">
            <span className="text-xs text-gray-400 font-mono">{fileName}</span>
            <span className="text-xs text-gray-500">
              {diff.filter(d => d.type === 'add').length} Ê∑ªÂä† / {diff.filter(d => d.type === 'del').length} Âà†Èô§
            </span>
          </div>
          <div className="overflow-x-auto max-h-96">
            <pre className="text-sm font-mono">
              {diff.map((line, idx) => (
                <div key={idx} className={`px-4 py-0.5 flex ${
                  line.type === 'add' ? 'bg-green-500/10 text-green-300' : 
                  line.type === 'del' ? 'bg-red-500/10 text-red-300' : 
                  'text-gray-400'
                }`}>
                  <span className="w-12 text-gray-600 select-none text-right pr-2 shrink-0">{line.lineOld || ''}</span>
                  <span className="w-12 text-gray-600 select-none text-right pr-2 shrink-0">{line.lineNew || ''}</span>
                  <span className="w-6 select-none shrink-0">{line.type === 'add' ? '+' : line.type === 'del' ? '-' : ' '}</span>
                  <span className="flex-1 whitespace-pre">{renderLine(line)}</span>
                </div>
              ))}
            </pre>
          </div>
        </div>
      );
    };

    // ============================================================================
    // Dependency Visualization Component
    // ============================================================================
    const DependencyGraph = ({ patches, dependencies, onPatchClick }) => {
      const fileGroups = useMemo(() => {
        const groups = {};
        patches.forEach((patch, index) => {
          const file = patch.file;
          if (!groups[file]) groups[file] = [];
          groups[file].push({ patch, index });
        });
        return groups;
      }, [patches]);
      
      const contentDeps = dependencies.filter(d => d.type === 'content');
      
      return (
        <div className="bg-gray-800/30 rounded-xl border border-gray-700/50 p-4">
          <div className="flex items-center gap-2 mb-4 text-sm font-medium text-gray-300">
            <Icons.Network />
            Ë°•‰∏Å‰æùËµñÂÖ≥Á≥ª
          </div>
          
          <div className="space-y-4">
            {Object.entries(fileGroups).map(([file, group]) => (
              <div key={file} className="bg-gray-900/50 rounded-lg p-3">
                <div className="text-xs text-gray-500 font-mono mb-2 flex items-center gap-2">
                  <Icons.FileText />
                  {file}
                </div>
                <div className="flex flex-wrap gap-2">
                  {group.map(({ patch, index }) => {
                    const hasContentDep = contentDeps.some(d => d.to === index);
                    const color = opColors[patch.operation] || opColors.REPLACE;
                    return (
                      <button
                        key={patch.id}
                        onClick={() => onPatchClick(patch.id)}
                        className={`relative px-3 py-1.5 rounded-lg text-xs font-medium transition-all ${color.bg} ${color.text} border ${color.border} hover:scale-105`}
                      >
                        #{index + 1} {patch.operation}
                        {hasContentDep && (
                          <span className="absolute -top-1 -right-1 w-3 h-3 bg-orange-500 rounded-full flex items-center justify-center text-[8px] text-white">
                            ‚ö°
                          </span>
                        )}
                      </button>
                    );
                  })}
                </div>
                {group.length > 1 && (
                  <div className="mt-2 text-xs text-gray-600 flex items-center gap-1">
                    <Icons.ArrowDown />
                    ÊâßË°åÈ°∫Â∫èÔºö‰ªéÂ∑¶Âà∞Âè≥
                  </div>
                )}
              </div>
            ))}
          </div>
          
          {contentDeps.length > 0 && (
            <div className="mt-4 p-3 bg-orange-500/10 rounded-lg border border-orange-500/30">
              <div className="text-xs font-medium text-orange-300 mb-2">‚ö° ÂÜÖÂÆπ‰æùËµñ</div>
              <div className="space-y-1">
                {contentDeps.map((dep, i) => (
                  <div key={i} className="text-xs text-orange-200/70">
                    Ë°•‰∏Å #{dep.from + 1} ‚Üí #{dep.to + 1}ÔºàÈîöÁÇπ‰æùËµñÂâçÂ∫èÂÜÖÂÆπÔºâ
                  </div>
                ))}
              </div>
            </div>
          )}
          
          <div className="mt-3 text-xs text-gray-500">
            üí° Âêå‰∏ÄÊñá‰ª∂ÁöÑË°•‰∏ÅÊåâÈ°∫Â∫è‰æùÊ¨°Â∫îÁî®ÔºåÂ∏¶ ‚ö° Ê†áËÆ∞Ë°®Á§∫ÈîöÁÇπ‰æùËµñÂâçÂ∫èË°•‰∏ÅÁöÑËæìÂá∫
          </div>
        </div>
      );
    };

    // ============================================================================
    // PatchCard Component
    // ============================================================================
    const PatchCard = ({ 
      patch, 
      index, 
      expanded, 
      onToggle, 
      onDelete, 
      onUpdate,
      onMoveUp,
      onMoveDown,
      canMoveUp,
      canMoveDown,
      fileContent,
      accumulatedContent,
      fuzzyMatch,
      onDragStart,
      onDragOver,
      onDrop,
      isDragging,
      isDropTarget,
      isActive
    }) => {
      const [isEditing, setIsEditing] = useState(false);
      const [editData, setEditData] = useState({
        file: patch.file,
        operation: patch.operation,
        anchor: patch.anchor,
        content: patch.content
      });

      const validation = useMemo(() => validatePatch(patch), [patch]);
      const effectiveContent = accumulatedContent || fileContent;
      const language = getLanguageFromFileName(patch.file);
      
      const applyResult = useMemo(() => {
        if (patch.operation === 'CREATE') return simulateApply('', patch, false);
        if (!effectiveContent) return null;
        
        const exactResult = simulateApply(effectiveContent, patch, false, patch.selectedMatchIndex);
        if (exactResult.success) return { ...exactResult, usedAccumulated: !!accumulatedContent };
        
        if (fuzzyMatch) {
          const fuzzyResult = simulateApply(effectiveContent, patch, true, patch.selectedMatchIndex);
          if (fuzzyResult.success) return { ...fuzzyResult, wasFuzzy: true, usedAccumulated: !!accumulatedContent };
          return { ...fuzzyResult, usedAccumulated: !!accumulatedContent };
        }
        
        return { ...exactResult, usedAccumulated: !!accumulatedContent };
      }, [effectiveContent, patch, fuzzyMatch, accumulatedContent]);
      
      const color = opColors[patch.operation] || opColors.REPLACE;

      const handleSaveEdit = (e) => {
        e?.stopPropagation();
        onUpdate({ ...patch, ...editData, raw: generateRaw(editData), selectedMatchIndex: null });
        setIsEditing(false);
      };

      const handleSelectMatch = (matchIdx) => {
        onUpdate({ ...patch, selectedMatchIndex: matchIdx });
      };

      const handleApplySuggestion = (suggestion) => {
        // Update anchor with the suggested code
        const newAnchor = suggestion.preview;
        setEditData(prev => ({ ...prev, anchor: newAnchor }));
        onUpdate({ ...patch, anchor: newAnchor, raw: generateRaw({ ...patch, anchor: newAnchor }), selectedMatchIndex: null });
      };

      const handleKeyDown = (e) => {
        if (e.key === 'Tab') {
          e.preventDefault();
          const target = e.target;
          const start = target.selectionStart;
          const newValue = target.value.substring(0, start) + '  ' + target.value.substring(target.selectionEnd);
          const fieldName = target.dataset.field;
          if (fieldName) {
            setEditData(prev => ({ ...prev, [fieldName]: newValue }));
            setTimeout(() => { target.selectionStart = target.selectionEnd = start + 2; }, 0);
          }
        }
        // Ctrl+S to save while editing
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
          e.preventDefault();
          handleSaveEdit();
        }
      };
      
      return (
        <div 
          className={`rounded-xl border ${color.border} ${color.bg} overflow-hidden transition-all duration-200 ${isDragging ? 'dragging' : ''} ${isDropTarget ? 'drag-over' : ''} ${isActive ? 'patch-active' : ''}`}
          draggable
          onDragStart={(e) => onDragStart(e, index)}
          onDragOver={(e) => onDragOver(e, index)}
          onDrop={(e) => onDrop(e, index)}
        >
          <div className="flex items-center gap-2 p-4 cursor-pointer hover:bg-white/5" onClick={onToggle}>
            <div className="drag-handle text-gray-600 hover:text-gray-400" onClick={(e) => e.stopPropagation()}>
              <Icons.GripVertical />
            </div>
            
            <div className="text-gray-500">
              {expanded ? <Icons.ChevronDown /> : <Icons.ChevronRight />}
            </div>
            
            <span className="text-gray-600 text-xs font-mono w-6">#{index + 1}</span>
            
            {isEditing ? (
              <select
                value={editData.operation}
                onChange={(e) => setEditData(prev => ({ ...prev, operation: e.target.value }))}
                onClick={(e) => e.stopPropagation()}
                className={`px-2 py-0.5 rounded text-xs font-mono font-medium ${color.text} bg-black/30 border ${color.border}`}
              >
                {operations.map(op => <option key={op} value={op}>{op}</option>)}
              </select>
            ) : (
              <span className={`px-2 py-0.5 rounded text-xs font-mono font-medium ${color.text} ${color.bg} border ${color.border}`}>
                {patch.operation}
              </span>
            )}
            
            {isEditing ? (
              <input
                type="text"
                value={editData.file}
                onChange={(e) => setEditData(prev => ({ ...prev, file: e.target.value }))}
                onClick={(e) => e.stopPropagation()}
                className="text-gray-300 font-mono text-sm flex-1 bg-black/30 border border-gray-600 rounded px-2 py-0.5"
              />
            ) : (
              <span className="text-gray-300 font-mono text-sm flex-1 truncate">{patch.file}</span>
            )}
            
            <div className="flex items-center gap-1">
              {!isEditing && (
                <>
                  {applyResult?.usedAccumulated && applyResult?.success && (
                    <span className="text-cyan-400 text-xs" title="Â¢ûÈáèÂåπÈÖç"><Icons.Layers /></span>
                  )}
                  {applyResult?.wasFuzzy && (
                    <span className="text-yellow-500 text-xs" title="ÂÆΩÊùæÂåπÈÖç"><Icons.Zap /></span>
                  )}
                  {patch.selectedMatchIndex !== null && (
                    <span className="text-orange-400 text-xs" title={`Â∑≤ÈÄâÊã©Á¨¨${patch.selectedMatchIndex + 1}Â§Ñ`}><Icons.Target /></span>
                  )}
                  {validation.warnings.length > 0 && (
                    <span className="text-yellow-500"><Icons.AlertTriangle /></span>
                  )}
                  {applyResult?.success === true && (
                    <span className="text-green-500"><Icons.CheckCircle /></span>
                  )}
                  {applyResult?.success === false && (
                    <span className="text-red-500"><Icons.XCircle /></span>
                  )}
                </>
              )}
            </div>
            
            <div className="flex items-center gap-1">
              <button
                onClick={(e) => { e.stopPropagation(); onMoveUp(); }}
                disabled={!canMoveUp}
                className="p-1 rounded hover:bg-gray-700/50 text-gray-500 hover:text-gray-300 disabled:opacity-30 disabled:cursor-not-allowed"
                title="‰∏äÁßª (Alt+‚Üë)"
              >
                <Icons.ArrowUp />
              </button>
              <button
                onClick={(e) => { e.stopPropagation(); onMoveDown(); }}
                disabled={!canMoveDown}
                className="p-1 rounded hover:bg-gray-700/50 text-gray-500 hover:text-gray-300 disabled:opacity-30 disabled:cursor-not-allowed"
                title="‰∏ãÁßª (Alt+‚Üì)"
              >
                <Icons.ArrowDown />
              </button>
            </div>
            
            {isEditing ? (
              <div className="flex items-center gap-1">
                <button onClick={handleSaveEdit} className="p-1.5 rounded-lg bg-green-500/20 hover:bg-green-500/30 text-green-400" title="‰øùÂ≠ò (Ctrl+S)"><Icons.Save /></button>
                <button onClick={(e) => { e.stopPropagation(); setIsEditing(false); }} className="p-1.5 rounded-lg bg-gray-700/50 hover:bg-gray-700 text-gray-400" title="ÂèñÊ∂à (Esc)"><Icons.X /></button>
              </div>
            ) : (
              <div className="flex items-center gap-1">
                <button onClick={(e) => { e.stopPropagation(); setEditData({ file: patch.file, operation: patch.operation, anchor: patch.anchor, content: patch.content }); setIsEditing(true); }} className="p-1.5 rounded-lg hover:bg-violet-500/20 text-gray-500 hover:text-violet-400"><Icons.Edit /></button>
                <button onClick={(e) => { e.stopPropagation(); onDelete(); }} className="p-1.5 rounded-lg hover:bg-red-500/20 text-gray-500 hover:text-red-400"><Icons.Trash2 /></button>
              </div>
            )}
          </div>
          
          {expanded && (
            <div className="px-4 pb-4 space-y-4">
              {!isEditing && (!validation.valid || validation.warnings.length > 0) && (
                <div className="space-y-1">
                  {validation.errors.map((err, i) => (
                    <div key={i} className="flex items-center gap-2 text-sm text-red-400"><Icons.XCircle /> {err}</div>
                  ))}
                  {validation.warnings.map((warn, i) => (
                    <div key={i} className="flex items-center gap-2 text-sm text-yellow-500"><Icons.AlertTriangle /> {warn}</div>
                  ))}
                </div>
              )}
              
              {!isEditing && applyResult && (
                <div>
                  <div className={`flex items-center gap-2 text-sm ${applyResult.success ? (applyResult.wasFuzzy ? 'text-yellow-400' : 'text-green-400') : 'text-red-400'}`}>
                    {applyResult.success ? <Icons.CheckCircle /> : <Icons.XCircle />}
                    {applyResult.message}
                    {applyResult.usedAccumulated && applyResult.success && (
                      <span className="text-xs text-cyan-400 ml-2">(Â¢ûÈáèÊ®°Âºè)</span>
                    )}
                  </div>
                  
                  {!applyResult.success && applyResult.multipleMatches && (
                    <div className="mt-3 p-4 bg-orange-500/10 rounded-lg border border-orange-500/30">
                      <div className="flex items-center gap-2 text-sm font-medium text-orange-300 mb-3">
                        <Icons.Target />
                        ÊâæÂà∞ {applyResult.matchCount} Â§ÑÂåπÈÖçÔºåËØ∑ÈÄâÊã©Ôºö
                      </div>
                      <div className="space-y-2 max-h-48 overflow-y-auto">
                        {applyResult.multipleMatches.map((match, idx) => (
                          <div 
                            key={idx}
                            className={`p-3 rounded-lg border cursor-pointer transition-all ${
                              patch.selectedMatchIndex === idx 
                                ? 'bg-orange-500/20 border-orange-500/50' 
                                : 'bg-black/20 border-gray-700 hover:border-orange-500/30'
                            }`}
                            onClick={(e) => { e.stopPropagation(); handleSelectMatch(idx); }}
                          >
                            <div className="flex items-center gap-2 mb-2">
                              <Icons.MapPin />
                              <span className="text-sm font-medium text-orange-300">‰ΩçÁΩÆ {idx + 1}: Ë°å {match.line}</span>
                              {patch.selectedMatchIndex === idx && (
                                <span className="text-xs bg-orange-500/30 px-2 py-0.5 rounded text-orange-200">Â∑≤ÈÄâÊã©</span>
                              )}
                            </div>
                            <SyntaxHighlightedCode code={match.preview} language={language} className="text-xs" />
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Smart Suggestions */}
                  {!applyResult.success && applyResult.smartSuggestions && !applyResult.multipleMatches && (
                    <SmartSuggestionPanel 
                      suggestions={applyResult.smartSuggestions} 
                      onApply={handleApplySuggestion}
                      fileName={patch.file}
                    />
                  )}
                  
                  {/* Legacy similar content (fallback) */}
                  {!applyResult.success && applyResult.similar && !applyResult.multipleMatches && !applyResult.smartSuggestions && (
                    <div className="mt-2 p-3 bg-blue-500/10 rounded-lg border border-blue-500/30">
                      <div className="text-xs font-medium text-blue-400 mb-2">È¶ñË°åÁõ∏‰ººÂÜÖÂÆπÔºö</div>
                      {applyResult.similar.map((sim, idx) => (
                        <div key={idx} className="mt-2 text-xs">
                          <div className="text-gray-400 mb-1">Ë°å {sim.line}:</div>
                          <SyntaxHighlightedCode code={sim.preview} language={language} className="text-xs" />
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              )}
              
              {(isEditing ? editData.operation !== 'CREATE' : patch.operation !== 'CREATE') && (
                <div>
                  <div className="text-xs text-gray-500 mb-1.5 font-medium flex items-center justify-between">
                    <span>ANCHOR</span>
                  </div>
                  {isEditing ? (
                    <textarea
                      value={editData.anchor}
                      onChange={(e) => setEditData(prev => ({ ...prev, anchor: e.target.value }))}
                      onKeyDown={handleKeyDown}
                      data-field="anchor"
                      className="edit-area w-full bg-black/30 rounded-lg p-3 text-sm text-gray-300 font-mono whitespace-pre border border-gray-600 focus:border-violet-500 resize-y min-h-[80px]"
                    />
                  ) : (
                    <SyntaxHighlightedCode code={patch.anchor} language={language} className="text-gray-300" />
                  )}
                </div>
              )}
              
              {(isEditing ? (editData.operation !== 'DELETE' || editData.content) : patch.content) && (
                <div>
                  <div className="text-xs text-gray-500 mb-1.5 font-medium">CONTENT</div>
                  {isEditing ? (
                    <textarea
                      value={editData.content}
                      onChange={(e) => setEditData(prev => ({ ...prev, content: e.target.value }))}
                      onKeyDown={handleKeyDown}
                      data-field="content"
                      className="edit-area w-full bg-black/30 rounded-lg p-3 text-sm text-green-300 font-mono whitespace-pre border border-gray-600 focus:border-violet-500 resize-y min-h-[80px]"
                    />
                  ) : (
                    <SyntaxHighlightedCode code={patch.content} language={language} className="text-green-300" />
                  )}
                </div>
              )}

              {isEditing && (
                <div className="flex items-center gap-2 pt-2 border-t border-gray-700/50">
                  <button onClick={handleSaveEdit} className="flex items-center gap-2 px-4 py-2 rounded-lg bg-green-500/20 hover:bg-green-500/30 text-green-400 text-sm font-medium">
                    <Icons.Save /> ‰øùÂ≠ò <span className="kbd text-[10px]">Ctrl+S</span>
                  </button>
                  <button onClick={(e) => { e.stopPropagation(); setIsEditing(false); }} className="flex items-center gap-2 px-4 py-2 rounded-lg bg-gray-700/50 hover:bg-gray-700 text-gray-400 text-sm font-medium">
                    <Icons.X /> ÂèñÊ∂à
                  </button>
                </div>
              )}
            </div>
          )}
        </div>
      );
    };

    // ============================================================================
    // Toast Component
    // ============================================================================
    const Toast = ({ message, type, onClose }) => {
      useEffect(() => {
        const timer = setTimeout(onClose, 3000);
        return () => clearTimeout(timer);
      }, [onClose]);

      const colors = {
        success: 'bg-green-500/20 border-green-500/50 text-green-300',
        error: 'bg-red-500/20 border-red-500/50 text-red-300',
        info: 'bg-blue-500/20 border-blue-500/50 text-blue-300'
      };

      return <div className={`fixed bottom-4 right-4 px-4 py-3 rounded-lg border ${colors[type]} z-50`}>{message}</div>;
    };

    // ============================================================================
    // Main App Component
    // ============================================================================
    function FIUPApp() {
      const [patchText, setPatchText] = useState('');
      const patchHistory = useHistory([]);
      const fileHistory = useHistory({});
      const [expandedPatch, setExpandedPatch] = useState(null);
      const [activePatchIndex, setActivePatchIndex] = useState(0);
      const [activeTab, setActiveTab] = useState('input');
      const [previewFile, setPreviewFile] = useState(null);
      const [toast, setToast] = useState(null);
      const [isDragging, setIsDragging] = useState(false);
      const [fuzzyMatch, setFuzzyMatch] = useState(true);
      const [incrementalMode, setIncrementalMode] = useState(true);
      const [showDeps, setShowDeps] = useState(false);
      const [dragIndex, setDragIndex] = useState(null);
      const [dropIndex, setDropIndex] = useState(null);
      const [showShortcuts, setShowShortcuts] = useState(false);
      const [showTemplates, setShowTemplates] = useState(false);
      
      const patches = patchHistory.current;
      const files = fileHistory.current;
      
      const setPatches = useCallback((newPatches) => {
        const result = typeof newPatches === 'function' ? newPatches(patches) : newPatches;
        patchHistory.push(result);
      }, [patches, patchHistory]);
      
      const setFiles = useCallback((newFiles) => {
        const result = typeof newFiles === 'function' ? newFiles(files) : newFiles;
        fileHistory.push(result);
      }, [files, fileHistory]);
      
      const showToast = (message, type = 'info') => setToast({ message, type });
      
      // Keyboard shortcuts
      useKeyboardShortcuts({
        undo: () => {
          if (patchHistory.canUndo) { patchHistory.undo(); showToast('Êí§ÈîÄ', 'info'); }
          if (fileHistory.canUndo) fileHistory.undo();
        },
        redo: () => {
          if (patchHistory.canRedo) { patchHistory.redo(); showToast('ÈáçÂÅö', 'info'); }
          if (fileHistory.canRedo) fileHistory.redo();
        },
        parse: () => {
          if (activeTab === 'input' && patchText.trim()) handleParse();
        },
        prevPatch: () => {
          if (patches.length > 0 && activePatchIndex > 0) {
            const newIndex = activePatchIndex - 1;
            setActivePatchIndex(newIndex);
            setExpandedPatch(patches[newIndex].id);
            setActiveTab('patches');
          }
        },
        nextPatch: () => {
          if (patches.length > 0 && activePatchIndex < patches.length - 1) {
            const newIndex = activePatchIndex + 1;
            setActivePatchIndex(newIndex);
            setExpandedPatch(patches[newIndex].id);
            setActiveTab('patches');
          }
        },
        escape: () => {
          setShowShortcuts(false);
          setShowTemplates(false);
        },
        newPatch: () => setShowTemplates(true),
        showHelp: () => setShowShortcuts(true),
      });
      
      // Drag and Drop handlers
      const handleDragStart = useCallback((e, index) => {
        setDragIndex(index);
        e.dataTransfer.effectAllowed = 'move';
      }, []);
      
      const handleDragOver = useCallback((e, index) => {
        e.preventDefault();
        setDropIndex(index);
      }, []);
      
      const handlePatchDrop = useCallback((e, toIndex) => {
        e.preventDefault();
        if (dragIndex !== null && dragIndex !== toIndex) {
          setPatches(prev => {
            const newPatches = [...prev];
            const [removed] = newPatches.splice(dragIndex, 1);
            newPatches.splice(toIndex, 0, removed);
            return newPatches;
          });
          showToast(`Ë°•‰∏Å #${dragIndex + 1} ÁßªÂä®Âà∞ #${toIndex + 1}`, 'success');
        }
        setDragIndex(null);
        setDropIndex(null);
      }, [dragIndex, setPatches]);
      
      // Move patch up/down
      const movePatch = useCallback((index, direction) => {
        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= patches.length) return;
        
        setPatches(prev => {
          const newPatches = [...prev];
          [newPatches[index], newPatches[newIndex]] = [newPatches[newIndex], newPatches[index]];
          return newPatches;
        });
        setActivePatchIndex(newIndex);
        showToast(`Ë°•‰∏Å #${index + 1} ${direction < 0 ? '‰∏äÁßª' : '‰∏ãÁßª'}`, 'success');
      }, [patches.length, setPatches]);
      
      // Accumulated contents calculation
      const accumulatedContents = useMemo(() => {
        if (!incrementalMode) return {};
        
        const result = {};
        const fileContents = {};
        
        patches.forEach((patch) => {
          const fileName = patch.file;
          const shortName = fileName.split('/').pop();
          const originalContent = files[fileName] || files[shortName] || '';
          
          if (!fileContents[fileName]) fileContents[fileName] = originalContent;
          
          if (patch.operation === 'CREATE') {
            result[patch.id] = '';
            fileContents[fileName] = patch.content;
            return;
          }
          
          result[patch.id] = fileContents[fileName];
          
          const applyResult = simulateApply(fileContents[fileName], patch, fuzzyMatch, patch.selectedMatchIndex);
          if (applyResult.success) fileContents[fileName] = applyResult.result;
        });
        
        return result;
      }, [patches, files, fuzzyMatch, incrementalMode]);
      
      // Dependencies
      const dependencies = useMemo(() => analyzeDependencies(patches, files, fuzzyMatch), [patches, files, fuzzyMatch]);
      
      const handleParse = useCallback(() => {
        const parsed = parseFIUP(patchText);
        setPatches(parsed);
        if (parsed.length > 0) {
          setExpandedPatch(parsed[0].id);
          setActivePatchIndex(0);
          setActiveTab('patches');
          showToast(`ÊàêÂäüËß£Êûê ${parsed.length} ‰∏™Ë°•‰∏Å`, 'success');
        } else {
          showToast('Êú™ÊâæÂà∞ÊúâÊïàÁöÑ FIUP Ë°•‰∏Å', 'error');
        }
      }, [patchText, setPatches]);
      
      // Handle template selection
      const handleTemplateSelect = useCallback((template) => {
        const newPatch = {
          id: crypto.randomUUID(),
          file: 'path/to/file.py',
          operation: template.operation,
          anchor: template.template.anchor,
          content: template.template.content,
          raw: '',
          selectedMatchIndex: null
        };
        newPatch.raw = generateRaw(newPatch);
        
        setPatches(prev => [...prev, newPatch]);
        setExpandedPatch(newPatch.id);
        setActivePatchIndex(patches.length);
        setActiveTab('patches');
        showToast(`Â∑≤Ê∑ªÂä†Ê®°Êùø: ${template.name}`, 'success');
      }, [patches.length, setPatches]);
      
      // File upload handlers
      const handleFileUpload = useCallback(async (e) => {
        const uploadedFiles = Array.from(e.target.files);
        const newFiles = {};
        
        for (const file of uploadedFiles) {
          if (file.name.endsWith('.zip')) {
            try {
              const zip = await JSZip.loadAsync(file);
              const promises = [];
              
              zip.forEach((relativePath, zipEntry) => {
                if (!zipEntry.dir && !relativePath.startsWith('__MACOSX') && !relativePath.startsWith('.')) {
                  promises.push(
                    zipEntry.async('string').then(content => {
                      newFiles[relativePath] = content;
                    }).catch(() => {})
                  );
                }
              });
              
              await Promise.all(promises);
              showToast(`‰ªé ${file.name} Ëß£Âéã ${Object.keys(newFiles).length} ‰∏™Êñá‰ª∂`, 'success');
            } catch (err) {
              showToast(`Ëß£ÂéãÂ§±Ë¥•: ${err.message}`, 'error');
            }
          } else {
            const content = await file.text();
            const path = file.webkitRelativePath || file.name;
            newFiles[path] = content;
          }
        }
        
        if (Object.keys(newFiles).length > 0) {
          setFiles(prev => ({ ...prev, ...newFiles }));
          if (!uploadedFiles[0]?.name.endsWith('.zip')) {
            showToast(`Â∑≤Âä†ËΩΩ ${Object.keys(newFiles).length} ‰∏™Êñá‰ª∂`, 'success');
          }
        }
        
        e.target.value = '';
      }, [setFiles]);

      const handleFileDrop = useCallback(async (e) => {
        e.preventDefault();
        setIsDragging(false);
        
        const items = Array.from(e.dataTransfer.items);
        const newFiles = {};
        
        const processEntry = async (entry, path = '') => {
          if (entry.isFile) {
            return new Promise((resolve) => {
              entry.file(async (file) => {
                if (file.name.endsWith('.zip')) {
                  try {
                    const zip = await JSZip.loadAsync(file);
                    const promises = [];
                    zip.forEach((relativePath, zipEntry) => {
                      if (!zipEntry.dir && !relativePath.startsWith('__MACOSX')) {
                        promises.push(
                          zipEntry.async('string').then(content => {
                            newFiles[relativePath] = content;
                          }).catch(() => {})
                        );
                      }
                    });
                    await Promise.all(promises);
                  } catch (err) {}
                } else {
                  const content = await file.text();
                  newFiles[path + file.name] = content;
                }
                resolve();
              });
            });
          } else if (entry.isDirectory) {
            const reader = entry.createReader();
            return new Promise((resolve) => {
              reader.readEntries(async (entries) => {
                for (const e of entries) {
                  await processEntry(e, path + entry.name + '/');
                }
                resolve();
              });
            });
          }
        };
        
        for (const item of items) {
          const entry = item.webkitGetAsEntry?.();
          if (entry) {
            await processEntry(entry);
          }
        }
        
        if (Object.keys(newFiles).length > 0) {
          setFiles(prev => ({ ...prev, ...newFiles }));
          showToast(`Â∑≤Âä†ËΩΩ ${Object.keys(newFiles).length} ‰∏™Êñá‰ª∂`, 'success');
        }
      }, [setFiles]);

      const handleDeleteFile = useCallback((fileName) => {
        setFiles(prev => {
          const newFiles = { ...prev };
          delete newFiles[fileName];
          return newFiles;
        });
        showToast(`Â∑≤ÁßªÈô§: ${fileName}`, 'info');
      }, [setFiles]);
      
      const handleDeletePatch = useCallback((id) => {
        setPatches(prev => prev.filter(p => p.id !== id));
      }, [setPatches]);

      const handleUpdatePatch = useCallback((updatedPatch) => {
        setPatches(prev => prev.map(p => p.id === updatedPatch.id ? updatedPatch : p));
      }, [setPatches]);
      
      const handlePreview = useCallback((fileName) => {
        const filePatches = patches.filter(p => p.file === fileName || p.file.endsWith('/' + fileName) || fileName.endsWith(p.file));
        const originalContent = files[fileName] || '';
        let content = originalContent;
        
        for (const patch of filePatches) {
          const result = simulateApply(content, patch, fuzzyMatch, patch.selectedMatchIndex);
          if (result.success) content = result.result;
        }
        
        setPreviewFile({ name: fileName, original: originalContent, modified: content });
      }, [patches, files, fuzzyMatch]);

      const handleApplyAndDownload = useCallback((fileName) => {
        const filePatches = patches.filter(p => p.file === fileName || p.file.endsWith('/' + fileName) || fileName.endsWith(p.file));
        
        const createPatch = filePatches.find(p => p.operation === 'CREATE');
        if (createPatch) {
          const blob = new Blob([createPatch.content], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName.split('/').pop();
          a.click();
          URL.revokeObjectURL(url);
          showToast(`Â∑≤ÂØºÂá∫: ${fileName}`, 'success');
          return;
        }
        
        const originalContent = files[fileName] || Object.entries(files).find(([k]) => fileName.endsWith(k))?.[1] || '';
        if (!originalContent) {
          showToast(`ËØ∑ÂÖà‰∏ä‰º†Êñá‰ª∂: ${fileName}`, 'error');
          return;
        }
        
        let content = originalContent;
        let successCount = 0;
        
        for (const patch of filePatches) {
          const result = simulateApply(content, patch, fuzzyMatch, patch.selectedMatchIndex);
          if (result.success) { content = result.result; successCount++; }
        }
        
        if (successCount === 0) {
          showToast('Ê≤°ÊúâÊàêÂäüÂ∫îÁî®ÁöÑË°•‰∏Å', 'error');
          return;
        }
        
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName.split('/').pop();
        a.click();
        URL.revokeObjectURL(url);
        showToast(`Â∑≤ÂØºÂá∫ (${successCount}/${filePatches.length} ÊàêÂäü)`, 'success');
      }, [patches, files, fuzzyMatch]);
      
      const handleCopyPatches = useCallback(() => {
        navigator.clipboard.writeText(patches.map(p => p.raw).join('\n\n'));
        showToast('Â∑≤Â§çÂà∂', 'success');
      }, [patches]);

      const handleExport = useCallback(() => {
        if (!previewFile) return;
        const blob = new Blob([previewFile.modified], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = previewFile.name.split('/').pop();
        a.click();
        URL.revokeObjectURL(url);
        showToast(`Â∑≤ÂØºÂá∫`, 'success');
      }, [previewFile]);
      
      const stats = useMemo(() => {
        const byOp = { REPLACE: 0, INSERT_AFTER: 0, INSERT_BEFORE: 0, DELETE: 0, CREATE: 0 };
        patches.forEach(p => { if (byOp.hasOwnProperty(p.operation)) byOp[p.operation]++; });
        return { byOp, total: patches.length };
      }, [patches]);

      const createFiles = useMemo(() => patches.filter(p => p.operation === 'CREATE').map(p => p.file), [patches]);
      
      // Match files with patches
      const matchedFiles = useMemo(() => {
        const matched = {};
        Object.keys(files).forEach(fileName => {
          const patchCount = patches.filter(p => 
            p.file === fileName || 
            p.file.endsWith('/' + fileName) || 
            fileName.endsWith(p.file) ||
            fileName.endsWith('/' + p.file)
          ).length;
          if (patchCount > 0) matched[fileName] = patchCount;
        });
        return matched;
      }, [files, patches]);

      return (
        <div 
          className={`min-h-screen bg-gradient-to-br from-gray-950 via-gray-900 to-gray-950 text-white ${isDragging ? 'ring-2 ring-inset ring-violet-500' : ''}`}
          onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
          onDragLeave={(e) => { e.preventDefault(); setIsDragging(false); }}
          onDrop={handleFileDrop}
        >
          {isDragging && (
            <div className="fixed inset-0 bg-violet-500/10 backdrop-blur-sm z-50 flex items-center justify-center pointer-events-none">
              <div className="bg-gray-900/90 border-2 border-dashed border-violet-500 rounded-2xl p-12 text-center">
                <div className="flex justify-center gap-4 mb-4 text-violet-400">
                  <Icons.Upload />
                  <Icons.Folder />
                  <Icons.Archive />
                </div>
                <p className="text-xl font-medium text-white">ÈáäÊîæÊñá‰ª∂‰ª•‰∏ä‰º†</p>
                <p className="text-gray-400 text-sm mt-2">ÊîØÊåÅÊñá‰ª∂„ÄÅÊñá‰ª∂Â§π„ÄÅZIPÂéãÁº©ÂåÖ</p>
              </div>
            </div>
          )}

          {/* Modals */}
          {showShortcuts && <ShortcutsModal onClose={() => setShowShortcuts(false)} />}
          {showTemplates && <TemplateSelector onSelect={handleTemplateSelect} onClose={() => setShowTemplates(false)} />}

          <header className="border-b border-gray-800/50 backdrop-blur-sm bg-gray-900/30 sticky top-0 z-10">
            <div className="max-w-7xl mx-auto px-4 sm:px-6 py-3 flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="w-9 h-9 rounded-xl bg-gradient-to-br from-violet-500 to-fuchsia-500 flex items-center justify-center">
                  <Icons.Code size={18} />
                </div>
                <div>
                  <h1 className="text-base font-semibold">FIUP Tool v3.5</h1>
                  <p className="text-xs text-gray-500 hidden sm:block">Â¢ûÂº∫Áâà ¬∑ ËØ≠Ê≥ïÈ´ò‰∫Æ ¬∑ Ë°åÂÜÖDiff</p>
                </div>
              </div>
              
              <div className="flex items-center gap-2">
                {/* Undo/Redo */}
                <div className="flex items-center gap-1 mr-2">
                  <button
                    onClick={() => { patchHistory.undo(); fileHistory.undo(); showToast('Êí§ÈîÄ', 'info'); }}
                    disabled={!patchHistory.canUndo}
                    className="p-2 rounded-lg hover:bg-gray-800 text-gray-400 hover:text-white disabled:opacity-30 disabled:cursor-not-allowed"
                    title="Êí§ÈîÄ (Ctrl+Z)"
                  >
                    <Icons.Undo />
                  </button>
                  <button
                    onClick={() => { patchHistory.redo(); fileHistory.redo(); showToast('ÈáçÂÅö', 'info'); }}
                    disabled={!patchHistory.canRedo}
                    className="p-2 rounded-lg hover:bg-gray-800 text-gray-400 hover:text-white disabled:opacity-30 disabled:cursor-not-allowed"
                    title="ÈáçÂÅö (Ctrl+Shift+Z)"
                  >
                    <Icons.Redo />
                  </button>
                </div>
                
                <button
                  onClick={() => setShowTemplates(true)}
                  className="flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg text-xs font-medium bg-gradient-to-r from-violet-500/20 to-fuchsia-500/20 text-violet-300 border border-violet-500/30 hover:border-violet-400/50 transition-all"
                  title="Ë°•‰∏ÅÊ®°Êùø (Ctrl+N)"
                >
                  <Icons.Template />
                  <span className="hidden sm:inline">Ê®°Êùø</span>
                </button>
                
                <button
                  onClick={() => setIncrementalMode(!incrementalMode)}
                  className={`flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg text-xs font-medium transition-all ${
                    incrementalMode ? 'bg-cyan-500/20 text-cyan-400 border border-cyan-500/30' : 'bg-gray-800/50 text-gray-400 border border-gray-700'
                  }`}
                  title="Â¢ûÈáèÊ®°Âºè"
                >
                  <Icons.Layers />
                  <span className="hidden sm:inline">Â¢ûÈáè</span>
                </button>
                <button
                  onClick={() => setFuzzyMatch(!fuzzyMatch)}
                  className={`flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg text-xs font-medium transition-all ${
                    fuzzyMatch ? 'bg-yellow-500/20 text-yellow-400 border border-yellow-500/30' : 'bg-gray-800/50 text-gray-400 border border-gray-700'
                  }`}
                  title="ÂÆΩÊùæÂåπÈÖç"
                >
                  <Icons.Zap />
                  <span className="hidden sm:inline">ÂÆΩÊùæ</span>
                </button>
                <button
                  onClick={() => setShowDeps(!showDeps)}
                  className={`flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg text-xs font-medium transition-all ${
                    showDeps ? 'bg-indigo-500/20 text-indigo-400 border border-indigo-500/30' : 'bg-gray-800/50 text-gray-400 border border-gray-700'
                  }`}
                  title="‰æùËµñËßÜÂõæ"
                >
                  <Icons.Network />
                  <span className="hidden sm:inline">‰æùËµñ</span>
                </button>
                <button
                  onClick={() => setShowShortcuts(true)}
                  className="p-2 rounded-lg hover:bg-gray-800 text-gray-400 hover:text-white"
                  title="Âø´Êç∑ÈîÆ (?)"
                >
                  <Icons.Keyboard />
                </button>
                <a href="https://github.com/Thankyou-Cheems/FIUP" target="_blank" className="p-2 rounded-lg hover:bg-gray-800 text-gray-400 hover:text-white">
                  <Icons.Github />
                </a>
              </div>
            </div>
          </header>
          
          <main className="max-w-7xl mx-auto px-4 sm:px-6 py-6">
            <div className="flex flex-col lg:flex-row gap-6">
              {/* Sidebar */}
              <div className="lg:w-72 xl:w-80 flex-shrink-0">
                <div className="lg:sticky lg:top-20 space-y-4">
                  {/* File Upload */}
                  <div className="bg-gray-800/30 rounded-xl border border-gray-700/50 p-4">
                    <div className="text-sm font-medium text-gray-300 mb-3 flex items-center gap-2">
                      <Icons.Upload />
                      ‰∏ä‰º†Êñá‰ª∂
                    </div>
                    <div className="grid grid-cols-3 gap-2">
                      <label className="flex flex-col items-center gap-1 p-3 rounded-lg border border-dashed border-gray-600 hover:border-gray-500 cursor-pointer transition-colors">
                        <Icons.FileText />
                        <span className="text-xs text-gray-400">Êñá‰ª∂</span>
                        <input type="file" multiple className="hidden" onChange={handleFileUpload} />
                      </label>
                      <label className="flex flex-col items-center gap-1 p-3 rounded-lg border border-dashed border-gray-600 hover:border-gray-500 cursor-pointer transition-colors">
                        <Icons.Folder />
                        <span className="text-xs text-gray-400">Êñá‰ª∂Â§π</span>
                        <input type="file" webkitdirectory="" className="hidden" onChange={handleFileUpload} />
                      </label>
                      <label className="flex flex-col items-center gap-1 p-3 rounded-lg border border-dashed border-gray-600 hover:border-gray-500 cursor-pointer transition-colors">
                        <Icons.Archive />
                        <span className="text-xs text-gray-400">ZIP</span>
                        <input type="file" accept=".zip" className="hidden" onChange={handleFileUpload} />
                      </label>
                    </div>
                  </div>

                  {/* File List */}
                  <div className="bg-gray-800/30 rounded-xl border border-gray-700/50 overflow-hidden">
                    <div className="flex items-center justify-between px-4 py-3 border-b border-gray-700/50">
                      <h3 className="text-sm font-medium text-gray-300">Êñá‰ª∂ ({Object.keys(files).length})</h3>
                      {Object.keys(files).length > 0 && (
                        <button onClick={() => { setFiles({}); showToast('Â∑≤Ê∏ÖÁ©∫', 'info'); }} className="text-xs text-gray-500 hover:text-red-400">Ê∏ÖÁ©∫</button>
                      )}
                    </div>
                    <div className="max-h-48 overflow-y-auto">
                      {Object.keys(files).length === 0 ? (
                        <div className="px-4 py-6 text-center text-gray-600 text-sm">ÊöÇÊó†Êñá‰ª∂</div>
                      ) : (
                        <div className="p-2 space-y-1">
                          {Object.entries(files).slice(0, 20).map(([name, content]) => {
                            const patchCount = matchedFiles[name] || 0;
                            return (
                              <div key={name} className="flex items-center gap-2 p-2 rounded-lg group hover:bg-gray-700/30 text-xs">
                                <Icons.FileText />
                                <span className="flex-1 truncate text-gray-300 font-mono" title={name}>{name}</span>
                                {patchCount > 0 && <span className="px-1.5 py-0.5 rounded bg-violet-500/20 text-violet-400">{patchCount}</span>}
                                <button onClick={() => handleDeleteFile(name)} className="p-1 rounded opacity-0 group-hover:opacity-100 hover:bg-red-500/20 text-gray-500 hover:text-red-400">
                                  <Icons.X />
                                </button>
                              </div>
                            );
                          })}
                          {Object.keys(files).length > 20 && (
                            <div className="text-xs text-gray-500 text-center py-2">
                              ËøòÊúâ {Object.keys(files).length - 20} ‰∏™Êñá‰ª∂...
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Quick Actions */}
                  {patches.length > 0 && Object.keys(matchedFiles).length > 0 && (
                    <div className="bg-gradient-to-br from-violet-500/10 to-fuchsia-500/10 rounded-xl border border-violet-500/20 p-3">
                      <div className="text-xs font-medium text-gray-400 mb-2">‰∏ÄÈîÆÂ∫îÁî®</div>
                      <div className="space-y-1">
                        {Object.entries(matchedFiles).slice(0, 5).map(([fileName, count]) => (
                          <button key={fileName} onClick={() => handleApplyAndDownload(fileName)} className="w-full flex items-center gap-2 px-3 py-2 rounded-lg bg-violet-500/20 hover:bg-violet-500/30 text-violet-300 text-xs font-medium text-left">
                            <Icons.Download />
                            <span className="flex-1 truncate">{fileName.split('/').pop()}</span>
                            <span className="text-violet-400">{count}</span>
                          </button>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Shortcut hints */}
                  <div className="bg-gray-800/20 rounded-xl border border-gray-700/30 p-3">
                    <div className="text-xs text-gray-500 space-y-1">
                      <div className="flex justify-between"><span>Êí§ÈîÄ/ÈáçÂÅö</span><span><span className="kbd">Ctrl</span>+<span className="kbd">Z</span></span></div>
                      <div className="flex justify-between"><span>ÂàáÊç¢Ë°•‰∏Å</span><span><span className="kbd">Alt</span>+<span className="kbd">‚Üë‚Üì</span></span></div>
                      <div className="flex justify-between"><span>Êõ¥Â§öÂø´Êç∑ÈîÆ</span><span><span className="kbd">?</span></span></div>
                    </div>
                  </div>
                </div>
              </div>

              {/* Main Content */}
              <div className="flex-1 min-w-0">
                <div className="flex gap-1 p-1 bg-gray-800/50 rounded-xl mb-4 w-fit">
                  {[
                    { id: 'input', label: 'ËæìÂÖ•', icon: Icons.FileText },
                    { id: 'patches', label: `Ë°•‰∏Å (${stats.total})`, icon: Icons.Code },
                    { id: 'preview', label: 'È¢ÑËßà', icon: Icons.Eye }
                  ].map(tab => (
                    <button
                      key={tab.id}
                      onClick={() => setActiveTab(tab.id)}
                      className={`flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-all ${
                        activeTab === tab.id ? 'bg-violet-500 text-white' : 'text-gray-400 hover:text-white hover:bg-gray-700/50'
                      }`}
                    >
                      <tab.icon />
                      {tab.label}
                    </button>
                  ))}
                </div>

                {/* Dependency Graph */}
                {showDeps && patches.length > 0 && (
                  <div className="mb-4">
                    <DependencyGraph 
                      patches={patches} 
                      dependencies={dependencies}
                      onPatchClick={(id) => { 
                        setExpandedPatch(id); 
                        setActivePatchIndex(patches.findIndex(p => p.id === id));
                        setActiveTab('patches'); 
                      }}
                    />
                  </div>
                )}
            
                {activeTab === 'input' && (
                  <div className="space-y-4">
                    <div className="flex items-center justify-between">
                      <h2 className="text-lg font-medium">ËæìÂÖ• FIUP Ë°•‰∏Å</h2>
                      <div className="flex items-center gap-2">
                        <button
                          onClick={() => setShowTemplates(true)}
                          className="flex items-center gap-2 px-3 py-2 rounded-lg bg-gray-700/50 hover:bg-gray-700 text-gray-300 text-sm"
                        >
                          <Icons.Plus /> ‰ªéÊ®°ÊùøÊñ∞Âª∫
                        </button>
                        <button
                          onClick={handleParse}
                          disabled={!patchText.trim()}
                          className="flex items-center gap-2 px-4 py-2 rounded-lg bg-violet-500 hover:bg-violet-600 disabled:opacity-50 disabled:cursor-not-allowed font-medium text-sm"
                        >
                          <Icons.Play /> Ëß£Êûê <span className="kbd text-[10px] ml-1">Ctrl+Enter</span>
                        </button>
                      </div>
                    </div>
                    
                    <textarea
                      value={patchText}
                      onChange={(e) => setPatchText(e.target.value)}
                      placeholder="Á≤òË¥¥ FIUP Ë°•‰∏ÅÂÜÖÂÆπ..."
                      className="w-full h-72 bg-gray-900/50 border border-gray-700/50 rounded-xl p-4 font-mono text-sm text-gray-300 placeholder-gray-600 focus:outline-none focus:border-violet-500/50 resize-none"
                    />
                    
                    <div className="text-xs text-gray-500 flex flex-wrap gap-4">
                      <span>‚úì ËØ≠Ê≥ïÈ´ò‰∫Æ</span>
                      <span>‚úì Ë°åÂÜÖDiff</span>
                      <span>‚úì Êô∫ËÉΩÈîöÁÇπÂª∫ËÆÆ</span>
                      <span>‚úì Ë°•‰∏ÅÊ®°Êùø</span>
                      <span>‚úì ÈîÆÁõòÂø´Êç∑ÈîÆ</span>
                    </div>
                  </div>
                )}
            
                {activeTab === 'patches' && (
                  <div className="space-y-3">
                    {stats.total > 0 && (
                      <div className="flex items-center gap-4 p-3 bg-gray-800/30 rounded-xl text-sm">
                        <div className="flex items-center gap-4 flex-1 flex-wrap">
                          {Object.entries(stats.byOp).map(([op, count]) => count > 0 && (
                            <div key={op} className="flex items-center gap-2">
                              <span className={`w-2 h-2 rounded-full ${opColors[op]?.text.replace('text-', 'bg-')}`} />
                              <span className="text-gray-400">{op}</span>
                              <span className="font-medium">{count}</span>
                            </div>
                          ))}
                        </div>
                        <button onClick={handleCopyPatches} className="flex items-center gap-1.5 px-3 py-1.5 rounded-lg bg-gray-700 hover:bg-gray-600 text-xs">
                          <Icons.Copy /> Â§çÂà∂
                        </button>
                      </div>
                    )}
                    
                    {patches.length === 0 ? (
                      <div className="text-center py-16 text-gray-500">
                        <div className="mx-auto mb-4 opacity-30"><Icons.Code size={48} /></div>
                        <p className="mb-4">ÊöÇÊó†Ë°•‰∏Å</p>
                        <button
                          onClick={() => setShowTemplates(true)}
                          className="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-violet-500/20 hover:bg-violet-500/30 text-violet-300 text-sm"
                        >
                          <Icons.Template /> ‰ªéÊ®°ÊùøÂàõÂª∫
                        </button>
                      </div>
                    ) : (
                      <div className="space-y-2">
                        {patches.map((patch, index) => (
                          <PatchCard
                            key={patch.id}
                            patch={patch}
                            index={index}
                            expanded={expandedPatch === patch.id}
                            onToggle={() => { 
                              setExpandedPatch(expandedPatch === patch.id ? null : patch.id);
                              setActivePatchIndex(index);
                            }}
                            onDelete={() => handleDeletePatch(patch.id)}
                            onUpdate={handleUpdatePatch}
                            onMoveUp={() => movePatch(index, -1)}
                            onMoveDown={() => movePatch(index, 1)}
                            canMoveUp={index > 0}
                            canMoveDown={index < patches.length - 1}
                            fileContent={files[patch.file] || Object.entries(files).find(([k]) => patch.file.endsWith(k) || k.endsWith(patch.file))?.[1]}
                            accumulatedContent={incrementalMode ? accumulatedContents[patch.id] : null}
                            fuzzyMatch={fuzzyMatch}
                            onDragStart={handleDragStart}
                            onDragOver={handleDragOver}
                            onDrop={handlePatchDrop}
                            isDragging={dragIndex === index}
                            isDropTarget={dropIndex === index && dragIndex !== index}
                            isActive={activePatchIndex === index}
                          />
                        ))}
                      </div>
                    )}
                  </div>
                )}
            
                {activeTab === 'preview' && (
                  <div className="space-y-4">
                    <div className="flex items-center gap-4">
                      <h2 className="text-lg font-medium">È¢ÑËßàÂèòÊõ¥</h2>
                      {previewFile && (
                        <button onClick={handleExport} className="flex items-center gap-2 px-3 py-1.5 rounded-lg bg-green-500/20 hover:bg-green-500/30 text-green-400 text-sm ml-auto">
                          <Icons.Download /> ÂØºÂá∫
                        </button>
                      )}
                    </div>
                    
                    <div className="flex flex-wrap gap-2">
                      {Object.keys(files).length === 0 ? (
                        <div className="w-full text-center py-8 border-2 border-dashed border-gray-700 rounded-xl text-gray-400">
                          ËØ∑ÂÖà‰∏ä‰º†Êñá‰ª∂
                        </div>
                      ) : (
                        Object.keys(matchedFiles).map(name => (
                          <button
                            key={name}
                            onClick={() => handlePreview(name)}
                            className={`flex items-center gap-2 px-3 py-2 rounded-lg border text-sm ${
                              previewFile?.name === name ? 'bg-violet-500/20 border-violet-500/50 text-violet-300' : 'bg-gray-800/50 border-gray-700/50 hover:border-gray-600 text-gray-300'
                            }`}
                          >
                            <Icons.FileText />
                            {name.split('/').pop()}
                            <span className="px-1.5 py-0.5 rounded bg-violet-500/30 text-xs">{matchedFiles[name]}</span>
                          </button>
                        ))
                      )}
                    </div>
                    
                    {previewFile && (
                      <div className="space-y-2">
                        <div className="flex items-center justify-between">
                          <h3 className="text-sm font-medium text-gray-400">{previewFile.name}</h3>
                          <button onClick={() => handlePreview(previewFile.name)} className="flex items-center gap-1 text-xs text-gray-500 hover:text-gray-300">
                            <Icons.RefreshCw /> Âà∑Êñ∞
                          </button>
                        </div>
                        <DiffView 
                          original={previewFile.original} 
                          modified={previewFile.modified} 
                          fileName={previewFile.name}
                          showInlineDiff={true}
                        />
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          </main>
          
          <footer className="border-t border-gray-800/50 mt-8">
            <div className="max-w-7xl mx-auto px-4 sm:px-6 py-4 flex items-center justify-between text-xs text-gray-500">
              <span>FIUP Tool v3.5</span>
              <span className="hidden sm:inline">ËØ≠Ê≥ïÈ´ò‰∫Æ ¬∑ Ë°åÂÜÖDiff ¬∑ Êô∫ËÉΩÂª∫ËÆÆ ¬∑ Ë°•‰∏ÅÊ®°Êùø ¬∑ ÈîÆÁõòÂø´Êç∑ÈîÆ</span>
              <a href="https://github.com/Thankyou-Cheems" target="_blank" className="hover:text-gray-300">ÁåπCheems</a>
            </div>
          </footer>

          {toast && <Toast message={toast.message} type={toast.type} onClose={() => setToast(null)} />}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<FIUPApp />);
  </script>
</body>
</html>
